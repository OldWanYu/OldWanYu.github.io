---
layout: post
title: 'React面试题'
date: 2020-04-12
author: 木一橙
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: React
---

> React前端面试题总结.



# 1. React简介

## 1.1 React介绍
+ React 是一个用于构建用户界面的 JAVASCRIPT库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
+ React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架都不满意，就决定自己写一套，用来架设 Instagram（照片交友） 的网站。做出来以后，发现这套东西很好用，**就在2013年5月开源了**。
+ React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。由于 React 的**设计思想极其独特**，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。
+ 清楚两个概念：
  + library（库）：小而巧的库，只提供了特定的API；优点就是 船小好掉头，可以很方便的从一个库切换到另外的库；但是代码几乎不会改变；比如从jQuery切换到

  + Framework（框架）：大而全的是框架；框架提供了一整套的解决方案；所以如果在项目中间，想切换到另外的框架，是比较困难的；



## 1.2 前端三大主流框架

- Angular.js：出来**较早**的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2 ~ NG5开始，进行了一系列的改革，也提供了组件化开发的概念；从NG2开始，也支持使用TS（TypeScript）进行编程；

+ Vue.js：**最火**（关注的人比较多）的一门前端框架，它是中国人开发的，对我们来说，文档要友好一些；

+ React.js：**最流行**（用的人比较多）的一门框架，因为它的设计很优秀；



## 1.3 React与Vue的对比

**1、监听数据变化的实现原理不同**

- Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能
- React 默认是通过比较引用地址的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染

为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。

因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。

**2、数据流的不同**

![img](assets\1574133046838.png)

大家都知道Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：

1. 父子组件之间，props 可以双向绑定
2. 组件与DOM之间可以通过 v-model 双向绑定

在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。所以现在我们只有 组件 <--–> DOM 之间的双向绑定这一种。

然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState()模式。

不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。

**3、模板渲染方式的不同**

在表层上， 模板的语法不同

- React 是通过JSX渲染模板
- 而Vue是通过一种拓展的HTML语法进行渲染

但其实这只是表面现象，毕竟React并不必须依赖JSX。

在深层上，模板的原理不同，这才是他们的本质区别：

- React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的
- Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现

**4、Vuex 和 Redux 的区别**

从表面上来说，store 注入和使用方式有一些区别。

在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：

- 使用 dispatch 和 commit 提交更新
- 通过 mapState 或者直接通过 this.$store 来读取数据

在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。

另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。

从实现原理上来说，最大的区别是两点：

- Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改
- Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）

**5、总结**

	React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用 Vue 的感觉。

## 1.4 React中几个核心的概念
### 1.4.1 虚拟DOM（Virtual Document Object Model）
 + **DOM的本质是什么**：浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API；
 + **什么是React中的虚拟DOM**：是框架中的概念，是程序员用JS对象来模拟页面上的 DOM 和 DOM嵌套；
 + **为什么要实现虚拟DOM（虚拟DOM的目的）：**为了实现页面中DOM 元素的高效更新
 + **DOM和虚拟DOM的区别**：


![](images/虚拟DOM的概念.png)

![1552877849641](assets\1552877849641.png)

### 1.4.2 react的Diff算法

![Diff算法图](assets/Diff.png)

	其实传统diff算法就是对每个节点一一对比，循环遍历所有的子节点，然后判断子节点的更新状态。通过循环递归对节点进行依次对比，算法时间复杂度达到 O(n^3) ，n是树的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。即便是CPU快能执行30亿条命令，也**很难在一秒内**计算出差异。。
	
	React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。react根据自己的特点，实现了部分代码的简化。

![1552878167661](assets\1552878167661.png)

#### a) tree diff

```
（1）React通过updateDepth对Virtual DOM树进行层级控制。
（2）对树分层比较，两棵树只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。
（3）只需遍历一次就能完成整棵DOM树的比较。
```

![1562723697592](assets\1562723697592.png)

```
那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？
答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。
```

![1562723819718](assets\1562723819718.png)

	如上图所示，以A为根节点的整棵树会被**重新创建，而不是移动**，因此 **官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点**。

#### b) component diff

```
React应用是基于组件构建的，对于组件的比较优化侧重于以下几点：
1. 同一类型组件遵从tree diff比较v-dom树
2. 不同类型组件，先将该组件归类为dirty component，替换下整个组件下的所有子节点
3. 同一类型组件Virtual Dom没有变化，React允许开发者使用shouldComponentUpdate（）来判断该组件是否进行diff，运用得当可以节省diff计算时间，提升性能
```

![1562723945651](assets\1562723945651.png)

```
如上图，当组件D → 组件G时，diff判断为不同类型的组件，虽然它们的结构相似甚至一样，diff仍然不会比较二者结构，会直接销毁D及其子节点，然后新建一个G相关的子tree，这显然会影响性能，官方虽然认定这种情况极少出现，但是开发中的这种现象造成的影响是非常大的。
```

#### c) element diff

```
对于同一层级的element节点，diff提供了以下3种节点操作：
1. INSERT_MARKUP 插入节点
2. MOVE_EXISING 移动节点
3. REMOVE_NODE 移除节点
```

![1562724094202](assets\1562724094202.png)

```
一般diff在比较集合[A,B,C,D]和[B，A，D，C]的时候会进行全部对比，即按对应位置逐个比较，发现每个位置对应的元素都有所更新，则把旧集合全部移除，替换成新的集合，如上图，但是这样的操作在React中显然是复杂、低效、影响性能的操作，因为新集合中所有的元素都可以进行复用，无需删除重新创建，耗费性能和内存，只需要移动元素位置即可。

React对这一现象做出了一个高效的策略：允许开发者对同一层级的同组子节点添加唯一key值进行区分。意义就是代码上的一小步，性能上的一大步，甚至是翻天覆地的变化！
```

# 2. React入门案例

## 2.1 创建webpack应用

1. 运行`npm init -y` 快速初始化项目

2. 在项目根目录创建`src`源代码目录和`dist`产品目录

3. 在 src 目录下创建 `index.html和main.js`

4. 安装webpack和webpack-cli

   ```javascript
   npm install webpack@4.27.1 -d
   npm install webpack-cli -d       提供一些基本命令(比如webpack命令)
   ```

5. 创建webpack.config.js

   ```javascript
   const path = require("path")
   //webpack基于node构建的，所有用的是CommonJS模块化规范
   module.exports = {
       mode:"development",
       entry: path.join(__dirname, './src/main.js'),
       output: {
           path: path.join(__dirname, './dist'),
           filename: 'bundle.js'
       },
   }
   ```

6. index.html

   ```javascript
   <head>
       <meta charset="UTF-8">
       <title>Title</title>

       <script src="../dist/bundle.js"></script>
   </head>
   ```

7. 使用webpack命令打包项目，运行index.html查看结果

   ```
   webpack
   ```

8. 配置webpack-dev-server

   ```javascript
   #1.安装webpack-dev-serve
   npm install  webpack-dev-server -d

   #2.package.json的scripts添加dev
    "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "dev": "webpack-dev-server --open --port 3000 --hot --host 127.0.0.1"
     },

    #3.npm run dev     webpack-dev-server将打包后的bundle.js托管到项目根路径下(内存中)，所以可以通过下面路径访问
     http://localhost:8080/bundle.js    

   #4.修改index.html中引入bundle.js的路径
   <head>
       <meta charset="UTF-8">
       <title>Title</title>

   	<!--使用webpack-dev-server打包后内存中的bundle.js-->
       <script src="../bundle.js"></script>
   </head>
   ```

9. 使用html-webpack-plugin将index.html配置到内存

   ```javascript
   #1.安装html-webpack-plugin
   npm i html-webpack-plugin@3.2.0 --save-dev

   #2.修改webpack.config.js配置
   // 导入自动生成HTMl文件的插件
   var htmlWebpackPlugin = require('html-webpack-plugin');

   module.exports = {
       entry: path.join(__dirname, './src/main.js'),
       output: { 
           path: path.join(__dirname, './dist'), 
           filename: 'bundle.js' 
       },
       plugins: [ 
           // 添加plugins节点配置插件
           new htmlWebpackPlugin({
               template:path.resolve(__dirname, 'src/index.html'),//模板路径
               filename:'index.html'//自动生成的HTML文件的名称
           })
       ],
   }
   ```

## 2.2 在webpack中使用 react

1. 运行 `npm install react react-dom -S` 安装包

   + react： 专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中
   + react-dom： 专门进行DOM操作的，最主要的应用场景，就是`ReactDOM.render()`

2. 在`index.html`页面中，创建容器：

   ```html
   <!-- 容器，将来，使用 React 创建的虚拟DOM元素，都会被渲染到这个指定的容器中 -->
   <div id="app"></div>
   ```

3. main.js导入包：

   ```js
   import React from 'react'                        // 创建组件、虚拟DOM元素，生命周期
   import ReactDOM from 'react-dom'      // 把创建好的 组件 和 虚拟DOM 放到页面上展示的
   ```

4. 创建虚拟DOM元素：

   ```jsx
   // 这是 创建虚拟DOM元素的 API    <h1 title="啊，五环" id="myh1">你比四环多一环</h1>
   //  第一个参数： 字符串类型的参数，表示要创建的标签的名称
   //  第二个参数：对象类型的参数， 表示 创建的元素的属性节点
   //  第三个参数： 子节点（包括 其它 虚拟DOM 获取 文本子节点）
   //  参数n :  其它子节点
   const myh1 = React.createElement('h1', { title: '啊，五环', id: 'myh1' }, '你比四环多一环')

   const mydiv = React.createElement('div', null, '这是一个div元素', myh1)
   ```


5. 渲染：

   ```js
   // 3. 渲染虚拟DOM元素
   // 参数1： 表示要渲染的虚拟DOM对象
   // 参数2： 指定容器,注意：这里不能直接放 容器元素的Id字符串，需要放一个容器的DOM对象
   ReactDOM.render(myh1, document.getElementById('app'))
   ```


## 2.3 JSX语法

> 什么是JSX语法：就是符合 xml 规范的 JS 语法；（语法格式相对来说，要比HTML严谨很多）

### 2.3.1 启用 JSX 语法

	浏览器目前还不支持 ES6 模块，比如这种ES6语法在浏览器和node中都不被支持    `import fs from 'fs'`，为了现在就能使用，我们可以使用转码器(ES6-->ES5)，也可以使用Browserify。
	
	知名度比较大的转码器有Traceur和babel，babel将ES6代码编译为大多数浏览器（包括IE9）支持的ES5代码。Browserify可以让我们遵循CommonJS规范书写代码，然后经过包装在浏览器中使用。

+ 安装 `babel` 插件

  - 运行`npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev`
  - 运行`npm i babel-preset-env babel-preset-stage-0 --save-dev`

+ 安装能够识别转换jsx语法的包 `babel-preset-react` 

  + 运行`npm i babel-preset-react -D`

+ 添加 `.babelrc` 配置文件

  ```json
  {
    "presets": ["env", "stage-0", "react"],
    "plugins": ["transform-runtime"]
  }
  ```

+ 添加babel-loader配置项：

  ```js
  module: { //要打包的第三方模块
      rules: [
        { test: /\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/ }
      ]
  }
  ```


```javascript
# 在main.js中使用JSX语法 
const mydiv2 = <div><h1>哈哈</h1></div>;
ReactDOM.render(mydiv2, document.getElementById('app'))

#webstrom中JSX语法报错：
Languages & Frameworks > JavaScript设置为JSX Harmony
```

### 2.3.2 JSX 语法

	JSX语法的本质：并不是直接把 jsx 渲染到页面上，而是内部通过 createElement 再渲染到页面；
	
	在 jsx 中混合写入 js 表达式：在 jsx 语法中，要把 JS代码写到    `{ }` 中

```javascript
// 1. 导入包
import React from 'react'
import ReactDOM from 'react-dom'

//2. JSX中使用数值、字符串、bool、数组等信息
let a = 10
let str = '你好，中国'
let boo = false
let title = '999'
const h1 = <h1>红火火恍恍惚惚</h1>
const arr = [
  <h2>这是h2</h2>,
  <h3>这是h3</h3>
]
const arrStr = ['毛利兰', '柯南', '小五郎', '灰原哀']

// 定义一个空数组，将来用来存放 名称 标签【方案1】
const nameArr = []
// 注意： React 中，需要把 key 添加给 被 forEach 或 map 或 for 循环直接控制的元素
arrStr.forEach(item => {
  const temp = <h5 key={item}>{item}</h5>
  nameArr.push(temp)
})

// 数组的 map 方法, map 中必须写 return
/* const result = arrStr.map(item => {
  return item + '~~'
})
console.log(result) */

// 3. 调用 render 函数渲染   JSX  XML 比 HTML 严格多了
// 在JSX要使用JS，则需要把 JS 代码写到 {} 中
ReactDOM.render(<div>
  {a + 2}
  <hr />
  {str}
  <hr />
  {boo ? '条件为真' : '条件为假'}
  <hr />
  <p title={title}>这是p标签</p>
  {h1}
  <hr />
  {/* {arr} */}
  {
    // 这是注释，你看不见我
  }
  <hr />
  {nameArr}
  <hr />
  {arrStr.map(item => <div key={item}><h3>{item}</h3>
  </div>)}
  <hr />

  <label htmlFor="ooo">11111</label>
</div>, document.getElementById('app'))
        
                
 #注意点：
1. 在 JSX 中 写注释：推荐使用{ /* 这是注释 */ }
2. 为 JSX 中的htmlFor替换label的for属性
3. 在 JSX 创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；
4. 在 JSX 语法中，标签必须成对出现，如果是单标签，则必须自闭和！
```

> 当 编译引擎，在编译JSX代码的时候，如果遇到了`<`那么就把它当作 HTML代码去编译，如果遇到了 `{}` 就把 花括号内部的代码当作普通JS代码去编译；

# 3. React中创建组件

## 3.1 使用构造函数来创建组件

> 如果要接收外界传递的数据，需要在构造函数的参数列表中使用`props`来接收；
>
> 必须要向外return一个合法的JSX创建的虚拟DOM；

### 3.1.1 创建组件

```jsx
// 第一种创建组件的方式 ： 注意构造函数首字母必须大写
// 构造函数必须是纯函数 ：因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果
function Hello (props) { 
    // 如果 在一个组件种 return 一个 null。则表示此组件是空的，什么都不会渲染
	// return null 
    // 在组件中，必须 返回一个 合法的 JSX 虚拟DOM元素
	return <div>Hello 组件</div>
}
```
### 3.1.2 为组件传递数据

```jsx
// 1. 导入包
import React from 'react'
import ReactDOM from 'react-dom'

function Hello(props) {
  // props.name = 'zs'     不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值;
  console.log(props)
  return <div>这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}</div>
}


const dog = {
  name: '大黄',
  age: 3,
  gender: '雄'
}

ReactDOM.render(<div>
  123
  {/* 直接把 组件的名称，以标签形式，丢到页面上即可 */}
  <Hello name={dog.name} age={dog.age} gender={dog.gender}></Hello>
  {/* 使用{...obj}属性扩散传递数据 */}
  <Hello {...dog}></Hello>
</div>, document.getElementById('app'))
```

```javascript
# 关于es6的展开运算符
var o2 = {
  age: 22,
  address: '中国北京',
  phone: '139999'
}

var o1 = {
  name: 'zs',
  ...o2
}

console.log(o1)
```
### 3.1.3 封装组件到独立文件

```javascript
#1. 新建Hello.jsx，并导出组件
import React from 'react'
// 第一种创建组件的方式
export default function Hello(props) {
  // 如果 在一个组件中 return 一个 null。则表示此组件是空的，什么都不会渲染
  // return null
  // 在组件中，必须 返回一个 合法的 JSX 虚拟DOM元素
  // props.name = 'zs'
  console.log(props)
  // 结论：不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值；

  return <div>这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}</div>
}

// 把组件暴露出去
// export default Hello

#2.导入Hello.jsx
  // 1. 导入包
  import React from 'react'
  import ReactDOM from 'react-dom'
  // 注意： 这里的 @ 符号，表示 项目根目录中的 src 这一层目录
  import Hello from '@/components/Hello.jsx'
  const dog = {
    name: '大黄',
    age: 3,
    gender: '雄'
  }

  ReactDOM.render(<div>
    123
    <Hello {...dog}></Hello>
  </div>, document.getElementById('app'))
                  
                  
#3.在导入组件的时候，如何省略组件的.jsx后缀名
// 打开 webpack.config.js ，并在导出的配置对象中，新增 如下节点：
  resolve: {
      extensions: ['.js', '.jsx', '.json'], // 表示，这几个文件的后缀名，可以省略不写
      alias: {
          '@': path.join(__dirname, './src')
      }
    }
```

##  3.2 使用 class 关键字来创建组件        

### 3.2.1 ES6的class关键字     

  ```javascript
// 创建了一个动物类
class Animal {
  // 每一个类中都有一个构造器，如果我们程序员没有手动指定构造器，那么，可以认为类内部有个隐形的、看不见的 空构造器，类似于 constructor(){}
  // 构造器的作用是每当 new 这个类的时候，必然会优先执行构造器中的代码
  constructor(name, age) {
    // 实例属性
    this.name = name
    this.age = age
  }

  // 在 class 内部，通过 static 修饰的属性，就是静态属性
  static info = "eee"

  // 这是动物的实例方法(挂载到原型对象上的实例方法)
  jiao() {
    console.log('动物的实例方法')
  }

  // 这是 动物 类的静态方法（今后用的不多）
  static show() {
    console.log('这是 Animal 的静态 show 方法')
  }
}

const a1 = new Animal('大黄', 3)
console.log(a1)
// console.log(a1.name)// 实例属性
// console.log(a1.age) // 实例属性
console.log(Animal.info) // info 是 Animal 的静态属性
a1.jiao() // 这是实例方法
Animal.show() // 静态方法

//其实静态属性和静态方法都挂载到了constructor上面，而构造器又指向了函数本身，所以可以直接通过函数名来调用静态属性和静态方法
  ```

	ES6的class只是一个语法糖，其本质仍然是通过之前的构造函数来创建对象，而对应的实例属性、实例方法、静态属性、静态方法实质都是向对应的原型和constructor中新增属性和方法，没有实质的变化。

### 3.2.2 class继承

```javascript
// 这是父类 
class Person {
  constructor(name, age){
    this.name = name
    this.age = age
  }

  // 打招呼 的 实例方法
  sayHello(){
    console.log('大家好')
  }
}


class American extends Person {
  constructor(name, age){
    // super 是一个函数，它是父类的构造器；子类中的 super其实就是父类constructor 构造器的一个引用；
    super(name, age)
  }
}

const a1 = new American('Jack', 20)
console.log(a1)
a1.sayHello()


// 这是子类 中国人
class Chinese extends Person{
  // IDNumber 身份证号 【中国人独有的】，既然是独有的，就不适合 挂载到 父类上；
  constructor(name, age, IDNumber){
    super(name, age)
    // 语法规范：在子类中， this 只能放到 super 之后使用
    this.IDNumber = IDNumber
  }
}

const c1 = new Chinese('张三', 22, '130428******')
console.log(c1)
c1.sayHello()
```

### 3.2.3 基于class关键字创建组件

最基本的组件结构：

```jsx
//让自己的组件继承React.Compoent，重写render方法
class 组件名称 extends React.Component {
    render(){
        return <div>这是 class 创建的组件</div>
    }
}
```
```javascript
// 1. 导入包
import React from 'react'
import ReactDOM from 'react-dom'

// class 关键字创建组件
class Movie extends React.Component {
  // 构造器
  constructor() {
    // 由于 Movie 组件，继承了 React.Component 这个父类，所以自定义的构造器中必须调用 super()
    super()
    // 只有调用了 super() 以后，才能使用 this 关键字。这个 this.state = {} 就相当于 Vue 中的 data() { return { } }
    this.state = { 
      msg: '大家好，我是 class 创建的 Movie组件'
    }
  }

  // render 函数的作用，是 渲染 当前组件所对应的 虚拟DOM元素
  render() {
    return <div>
      {/* 注意：在 class 组件内部，this 表示 当前组件的实例对象。props数据不可以修改，state数据可以修改 */}
      这是 Movie 组件 -- {this.props.name} -- {this.props.age} -- {this.props.gender}
      <h3>{this.state.msg}</h3>
    </div>
  }
}


const user = {
  name: 'zs',
  age: 22,
  gender: '男'
}

// 3. 调用 render 函数渲染
ReactDOM.render(<div>
  123
  {/* 这里的 Movie 标签，其实，就是 Movie 类的一个实例对象 */}
  {/* <Movie name={user.name} age={user.age}></Movie> */}
  <Movie {...user}></Movie>

</div>, document.getElementById('app'))
```

### 3.2.4 state的修改

#### a) 不能直接修改 State

```javascript
this.state.comment = 'Hello';

 //可以这样修改State
this.setState({comment: 'Hello'});
```

#### b) State的更新可能是异步的

	因为 `this.props` 和 `this.state` 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。

```javascript
//调用setState，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且React会出于性能原因，可能会将多次setState的状态修改合并成一次状态修改。所以不要依赖当前的State，计算下个State。
function add() {
  //Wrong
  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});
  //结果state的count为1
}

//Correct
add = () => {
    this.setState(state => ({
        count: state.count + 1
    }));
    this.setState(state => ({
        count: state.count + 1
    }));
    this.setState(state => ({
        count: state.count + 1
    }));
    //结果state的count为3
}


// Wrong   因为state和props的更新可能是异步的，所以并不能保证counter中所获取到的state和props是最新的
this.setState({
  counter: this.state.counter + this.props.increment,
});

// Correct    这边的state表示之前的state状态了
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));



//state的更新既可能是同步的,也可能是异步的。 准确地说,在React内部机制能检测到的地方, setState就是异步的;在React检测不到的地方,例如setInterval,setTimeout里,setState就是同步更新的。
```

#### c) 获取更新之后的state数据

```javascript
this.setState(
    { data: newData },
    () => {
        //这里打印的是最新的state值
        console.log(that.state.data);
    }
);


```

## 3.3 两种创建组件方式的对比

1. 用**构造函数**创建出来的组件：叫做“无状态组件”，只有props，没有自己的私有数据和生命周期函数
2. 用**class关键字**创建出来的组件：叫做“有状态组件”，有私有数据和生命周期函数

> 有状态组件和无状态组件之间的**本质区别**就是：有无state属性！无状态组件由于没有私有数据和生命周期函数，运行效率会比有状态组件高一些。

## 3.4 条件渲染

### 3.4.1 通过if来进行条件渲染

<https://blog.csdn.net/crystalqy/article/details/79066347>

```javascript
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return <UserGreeting />;
  }
  return <GuestGreeting />;
}

ReactDOM.render(
  // Try changing to isLoggedIn={true}:
  <Greeting isLoggedIn={false} />,
  document.getElementById('root')
);
```

### 3.4.2 通过&&进行条件渲染

```javascript
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          You have {unreadMessages.length} unread messages.
        </h2>
      }
    </div>
  );
}

const messages = ['React', 'Re: React', 'Re:Re: React'];
ReactDOM.render(
  <Mailbox unreadMessages={messages} />,
  document.getElementById('root')
);
```

### 3.4.3 三元运算符条件渲染

```javascript
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn ? (
        <LogoutButton onClick={this.handleLogoutClick} />
      ) : (
        <LoginButton onClick={this.handleLoginClick} />
      )}
    </div>
  );
}
```

### 3.4.4 阻止组件渲染

	在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 `render` 方法直接返回 `null`，而不进行任何渲染。

```js
render() {
  const isLoggedIn = this.state.isLoggedIn;
  if (!isLoggedIn) {
    return null;
  }
  return (
    <div>
      <LoginButton onClick={this.handleLoginClick} />
    </div>
  );
}
```

## 3.5 列表渲染

```javascript
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li key={number.toString()}>
      {number}
    </li>
  );
  return (
    <ul>{listItems}</ul>
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);

//key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。
//一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key。key在兄弟节点之间必须唯一
//当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：
const todoItems = todos.map((todo, index) =>
  // Only do this if items have no stable IDs
  <li key={index}>
    {todo.text}
  </li>
);
```

## 3.6 Fragment的使用

	有时，语义化的 HTML 会被破坏。比如当在 JSX 中使用 `<div>` 元素来实现 React 代码功能的时候，又或是在使用列表（`<ol>`， `<ul>` 和 `<dl>`）和 HTML `<table>` 时。 在这种情况下，我们应该使用 [React Fragments](https://react.docschina.org/docs/fragments.html) 来组合各个组件。

```javascript
import React, { Fragment } from 'react';

function ListItem({ item }) {
  return (
    <Fragment>
      <dt>{item.term}</dt>
      <dd>{item.description}</dd>
    </Fragment>
  );
}

function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        <ListItem item={item} key={item.id} />
      ))}
    </dl>
  );
}
```

## 3.7 React组合

react组合类似于Vue中的slot(插槽)，子组件的内容由父组件来指定

```javascript
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {/*子组件：占坑*/}
      {props.children}
    </div>
  );
}

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      {/*父组件中填坑*/}
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  );
}
```

	少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。

```javascript
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}

function App() {
  return (
    <SplitPane
      left={
        <Contacts />
      }
      right={
        <Chat />
      } />
  );
}
```

# 4. 评论列表案例

	思路：父组件中套了若干个评论Item子组件，所以需要创建两个组件，分别是：CmtList和CmtItem

## 4.1 案例完成

```javascript
#1. CmtList组件

import React from 'react'

// 导入 评论项 组件
import CmtItem from '@/components/CmtItem'

export default class CmtList extends React.Component {
  constructor() {
    super()
    this.state = {
      CommentList: [ // 评论列表数据
        { id: 1, user: '张三', content: '哈哈，沙发' },
        { id: 2, user: '李四', content: '哈哈，板凳' },
        { id: 3, user: '王五', content: '哈哈，凉席' },
        { id: 4, user: '赵六', content: '哈哈，砖头' },
        { id: 5, user: '田七', content: '哈哈，楼下山炮' }
      ]
    }
  }

  render() {
    return <div>
      {/* 注意：在 JSX 中如果想写行内样式了，不能为 style 设置字符串的值 */}
      {/* 而是应该 这么写：    style={ { color: 'red' } } */}
      {/* <h1 style="color:red;">这是评论列表组件</h1> */}
      {/* 在 行内样式中，如果 是 数值类型的样式，则可以不用引号包裹，如果是 字符串类型的 样式值，必须使用 引号包裹 */}
      <h1 style={{ color: 'red', fontSize: '35px', zIndex: 3, fontWeight: 200, textAlign: 'center' }}>这是评论列表组件</h1>


      {this.state.CommentList.map(item => <CmtItem {...item} key={item.id}></CmtItem>)}
    </div>
  }
}
                                  
#2.CmtItem组件
import React from 'react'

// 第一层封装：将 样式对象 和 UI 结构分离
// const itemStyle = { border: '1px dashed #ccc', margin: '10px', padding: '10px', boxShadow: '0 0 10px #ccc' }
// const userStyle = { fontSize: '14px' }
// const contentStyle = { fontSize: '12px' }

// 第二层封装：合并成一个大的样式对象
// const styles = {
//   item: { border: '1px dashed #ccc', margin: '10px', padding: '10px', boxShadow: '0 0 10px #ccc' },
//   user: { fontSize: '14px' },
//   content: { fontSize: '12px' }
// }

// 第三层封装：抽离为单独的 样式表 模块
import styles from '@/components/styles'

export default function CmtItem(props) {
  return <div style={styles.item}>
    <h1 style={styles.user}>评论人：{props.user}</h1>
    <p style={styles.content}>评论内容：{props.content}</p>
  </div>
}

#3.styles.js 
export default {
  item: { border: '1px dashed #ccc', margin: '10px', padding: '10px', boxShadow: '0 0 10px #ccc' },
  user: { fontSize: '14px' },
  content: { fontSize: '12px' }
}
```

## 4.2 使用CSS样式表

1. 修改 `webpack.config.js`这个配置文件，为 `css-loader` 添加参数：

   ```js
   npm install  style-loader  css-loader -D

   { test: /\.css$/, use: ['style-loader', 'css-loader'] } 
   ```

2. 创建CmtList.css

   ```css
   .title{
     color: red;
     text-align: center;
     font-weight: 200;
   }

   h1{
     font-style: italic;
   } 
   ```

3. 在CmtList组件中`import`导入样式表，并接收模块化的 CSS 样式对象：

   ```js
   import cssObj from '../css/CmtList.css' 
   console.log(cssObj)   // 发现打印是空对象,因为它并不像js有模块化的导出
   ```

4. 在需要的HTML标签上，使用`className`指定模块化的样式：

   ```jsx
   //这边不能<h1 className={cssObj.title}>评论列表组件</h1> 这样用，因为cssObj是空对象，但是在webpack打包后title会成为全局样式，所以可以直接使用className="title"
   <h1 className="title">评论列表组件</h1>
   ```

4. 问题

   > 当我们在CmtList.css中指定了h1标签的样式的时候，我们发现  `import cssObj from '../css/CmtList.css'` 之后，CmtList和CmtItem中的h1标签都变成了倾斜，说明CmtList中的样式全局生效了。原因在于webpack进行打包的时候会将所有内容打包到一个js文件，所以打包后的样式会全局生效。

## 4.3 使用CSS模块化

```javascript
#1. webpack.config.js  修改css的rules规则，开启css的模块化
{ test: /\.css$/, use: ['style-loader', 'css-loader?modules'] }       //modules表示为css启动模块化(启动模块化之后就有模块作用域)

#2.修改CmtList.css
/* 注意： 被 :local() 包裹起来的类名会被模块化； 默认情况下所有的类和id选择器都会被模块化了； */
.title{
  color: red;
  text-align: center;
  font-weight: 200;
}

/* css 模块化只针对类选择器 和 Id选择器生效， 不会对标签选择器模块化 */
h1{
  font-style: italic;
} 

/* 注意：被 :global() 包裹起来的类名，不会被模块化，而是会全局生效； */ 
:global(.test){
  font-style: italic;
}

#3.CmtList组件
import cssObj from '../css/CmtList.css' 
console.log(cssObj)   // 发现开启css模块化之后，这边打印就有内容了

//所以在页面通过属性绑定指定样式
<h1 className={cssobj.title}>这是评论列表组件</h1>

//如果要指定多个样式，可以像下面这样使用，其实就是className = {'样式1'  '样式2'}
<h1 className={[cssobj.title, 'test'].join(' ')}>这是评论列表组件</h1>
```

## 4.4 CSS模块化注意事项

1. 使用`localIdentName`自定义生成的类名格式，可选的参数有：

   - [path]  表示样式表 `相对于项目根目录` 所在路径

   - [name]  表示 样式表文件名称

   - [local]  表示样式的类名定义名称

   - [hash:length]  表示32位的hash值

     ```javascript
     {
         test: /\.css$/,
         loader: 'style-loader',
     },
     {
         test: /\.css$/,
         loader: 'css-loader',
         options: {
             //'css-loader?modules'  表示开启css的模块化
             modules: {
                 //path:表示原样式文件路径
                 //name:表示原样式文件的名称
                 //local:原样式的名称
                 //hash:base64:5  : 使用hash的base64编码，保留5位
                 localIdentName: '[path][name]__[local]__[hash:base64:5]',
             }
         },
     },
     ```

   ![1562727326828](assets\1562727326828.png)

2. 使用 `:local()` 和 `:global()`

   - `:local()`包裹的类名，是被模块化的类名，只能通过`className={cssObj.类名}`来使用。`:local`可以省略
   - `:global()`包裹的类名，是全局生效的，不会被 `css-modules` 控制，定义的类名是什么，就是使用定义的类名`className="类名"`

3. 注意：只有`.title`这样的类样式或者id选择器，才会被模块化控制，类似于`body`这样的标签选择器，不会被模块化控制；

## 4.5 Bootstrap样式的使用

```javascript
npm install bootstrap@3.3.5 
npm i url-loader file-loader --save-dev                   //url加载器

#CmtList中引入
import bootcss from 'bootstrap/dist/css/bootstrap.css'

#使用bootstrap样式
<!--下面这样用不行，因为bootstrap的css样式被模块化了-->
<button className="btn btn-primary">按钮啊</button>
<!--下面这样用才行-->
<button className={[bootcss.btn, bootcss['btn-primary']].join(' ')}>按钮</button>

#webpack.config.js rules添加下面规则
{ test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader
```



> 问题：如果都像上面那样使用bootstrap的样式，太麻烦了，我们期望引入bootstrap样式的时候还是<button className="btn btn-primary">按钮啊</button> 这样用，解决方案如下：

1. 把自己的样式表，定义为 `.less文件

2. 第三方的 样式表，还是 以 `.css` 结尾

3. 我们只需要为自己的 `.less文件，启用模块化即可；

4. 运行`npm i less less-loader -D` 安装能够解析`less`文件的loader

5. 添加loader规则：

   ```json
   //给less文件开启模块化
             {
               test: /\.less$/,
               loader: 'style-loader',
             },
             {
               test: /\.less$/,
               loader: 'css-loader',
               options: {
                   //'css-loader?modules'  表示开启css的模块化
                   modules: {
                     //path:表示原样式文件路径
                     //name:表示原样式文件的名称
                     //local:原样式的名称
                     //hash:base64:5  : 使用hash的base64编码，保留5位
                     localIdentName: '[path][name]__[local]__[hash:base64:5]',
                   }
               },
             },
             {
               test: /\.less$/,
               loader: 'less-loader',
             }
   ```

# 5.webpack配置详解

> 在实际开发中，一般会有两套项目方案：

- 一套是开发期间的项目，包含了测试文件、测试数据、开发工具、测试工具等相关配置，有利于项目的开发和测试，但是这些文件仅用于开发，发布项目时候需要剔除；
- 另一套是部署期间的项目，剔除了那些客户用不到的测试数据测试工具和文件，比较纯净，减少了项目发布后的体积，有利于安装和部署！

## 5.1 开发环境配置

```javascript
# 1.安装
npm init -y                                                       //项目初始化
npm install webpack@4.27.1 -d
npm install webpack-cli -d       提供一些基本命令(比如webpack命令)
npm install  webpack-dev-server -d
npm i html-webpack-plugin@3.2.0 --save-dev
npm install react react-dom -S
npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev
npm i babel-preset-env babel-preset-stage-0 --save-dev
npm i babel-preset-react -D
npm install  style-loader  css-loader -D
npm i less-loader less                                             //less加载器
npm i sass-loader node-sass --save-dev               //sass加载器
npm i url-loader file-loader --save-dev      


#2.webpack.config.js
const path = require('path')
// 导入自动生成HTMl文件的插件
var htmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    entry: path.join(__dirname, './src/main.js'),
    output: {
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js'
    },
    plugins: [
        // 添加plugins节点配置插件
        new htmlWebpackPlugin({
            template:path.resolve(__dirname, 'src/index.html'),//模板路径
            filename:'index.html'//自动生成的HTML文件的名称
        })
    ],
    module: { // 用来配置第三方loader模块的
        rules: [ // 文件的匹配规则
            { test: /\.css$/, use: ['style-loader', 'css-loader'] },//处理css文件的规则
            { test: /\.less$/, use: ['style-loader', 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]', 'less-loader'] },
            { test: /\.scss$/, use: ['style-loader', 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]', 'sass-loader'] },
            { test: /\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&name=[hash:8]-[name].[ext]' },
            { test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, // 处理 字体文件的 loader
            //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉
            { test: /\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/ }
        ]
    },
    resolve: {
        extensions: ['.js', '.jsx', '.json'], // 表示，这几个文件的后缀名，可以省略不写
        alias: {
            '@': path.join(__dirname, './src')
        }
    }
}

#3.项目入口文件  main.js
// 1. 导入包
import React from 'react'
import ReactDOM from 'react-dom'

import './css/index.css'


function Hello(props) {
    // props.name = 'zs'     不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值;
    console.log(props)
    return <div><div className="box"></div>这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}</div>
}

const dog = {
    name: '大黄',
    age: 3,
    gender: '雄'
}

ReactDOM.render(<div>
    {/* 使用{...obj}属性扩散传递数据 */}
    <Hello {...dog}></Hello>
</div>, document.getElementById('app'))

#4.index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div id="app"></div>
</body>
</html>
                
#5.css/index.css
div{
    border: 1px solid red;
}

.box{
    width: 300px;
    height: 500px;
    background: url("../images/1.jpg");
} 

#6.package.json
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot"
  }

#7.项目根目录 .babelrc
{
  "presets": ["env", "stage-0", "react"],
  "plugins": ["transform-runtime"]
}
```

## 5.2 生产环境配置文件

### a) 创建生产环境的配置文件

	为了满足我们的发布策略，需要新建一个配置文件，命名为`webpack.publish.config.js`，将`webpack.config.js`的配置拷贝过去，剔除一些开发配置项即可：

- 将`devServer`节点和热更新插件删掉：

```javascript
 devServer: {
        hot: true,
        open: true,
        port: 4321
    }

   new webpack.HotModuleReplacementPlugin()
```

1. 修改`url-loader`，将图片放入统一的images文件夹之下(**图片路径写在css文件中才会被打包，如果直接写在行内样式里面，不会被打包**)：

```javascript
{ test: /\.(png|jpg|gif)$/, use: 'url-loader?limit=5000&name=images/[hash:8]-[name].[ext]' }
```

2. 在`package.json`中的script节点下新增`dev`命令，通过`--config`指定webpack启动时要读取的配置文件：

```javascript
"pub": "webpack --config webpack.publish.config.js"
```

### b) 每次重新构建时候删除dist目录

1. 运行`npm i clean-webpack-plugin --save-dev`
2. 在头部引入这个插件：

```javascript
const {CleanWebpackPlugin } = require('clean-webpack-plugin');
```

3. 在`plugins`节点下使用这个插件：

```javascript
new CleanWebpackPlugin ()
```

### c) 分离第三方包

1. 和plugins节点平级添加下面配置：

```javascript
optimization: {
        splitChunks: {
            cacheGroups: {
                //自己写的代码打包 一个文件
                commons: {
                    name: "commons",
                    chunks: "initial",
                    //在分割之前，这个代码块最小应该被引用的次数
                    minChunks: 1,
                    //形成一个新代码块最小的体积
                    minSize: 0
                },
                //node_modules代码打包 一个文件
                vendor: {
                    chunks: "all",
                    test: /[\\/]node_modules[\\/]/,
                    name: "vendor",
                    minChunks: 1,
                    //入口最大的并行请求数
                    maxInitialRequests: 5,
                    // //形成一个新代码块最小的体积
                    minSize: 0,
                    //缓存组打包的先后优先级
                    priority: 100
                }
            }
        }
    },
```

3. `html-webpack-plugin`在生成`index.html`文件的时候，会自动将抽离的第三方包引入进去！

   ![1553329256785](assets\1553329256785.png)

### d) 优化压缩HTML文件

在`plugins`节点下的`htmlWebpackPlugin`插件中，添加`minify`子节点：

```javascript
new htmlWebpackPlugin({
    template: path.join(__dirname, './src/index.html'),
    filename: 'index.html',
    //压缩合并html页面
    minify: {
        collapseWhitespace: true, // 合并多余的空格
        removeComments: true, // 移除注释
        removeAttributeQuotes: true // 移除 属性上的双引号
    }
}),
```

其他优化项请参考：[html-minifier - github](https://github.com/kangax/html-minifier#options-quick-reference)

![1553150762968](assets\1553150762968.png)

### e) 抽取bundle.js中的CSS到指定文件

1. 运行`npm install extract-text-webpack-plugin@next `安装抽取CSS文件的插件。
2. 在配置文件中导入插件：

```javascript
const ExtractTextPlugin = require("extract-text-webpack-plugin");
```

3. 修改CSS和Sass的loader如下：

```json
{
    test: /\.css$/, use: ExtractTextPlugin.extract({
        fallback: "style-loader",
        use: ["css-loader"],
        publicPath: '../'         // 设置css背景图片的路径
    })
},
{
    test: /\.scss$/, use: ExtractTextPlugin.extract({
        fallback: "style-loader",
        use: [
            {
                loader: 'css-loader',
                options: {
                    modules: {
                        localIdentName: '[path][name]__[local]--[hash:base64:5]'
                    }
                }
            },
            {
                loader: 'sass-loader',
            }
        ],
        publicPath: '../'         // 设置css背景图片的路径
    })
},
{
    test: /\.less$/, use: ExtractTextPlugin.extract({
        fallback: "style-loader",
        use: [
            {
                loader: 'css-loader',
                options: {
                    modules: {
                        localIdentName: '[path][name]__[local]--[hash:base64:5]'
                    }
                }
            },
            {
                loader: 'less-loader',
            }
        ],
        publicPath: '../'         // 设置css背景图片的路径
    })
},
```

4. 在plugins节点下新增插件：

```javascript
new ExtractTextPlugin("css/styles.css"), // 抽取CSS文件的插件
```

### f) 压缩抽取出来的CSS文件

https://github.com/NMFR/optimize-css-assets-webpack-plugin

1. 运行`npm i optimize-css-assets-webpack-plugin --save-dev`安装插件到开发依赖。
2. 在配置文件头部导入插件：

```javascript
var OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
```

3. 在plugins节点下新增插件：

```javascript
 new OptimizeCssAssetsPlugin() // 压缩CSS文件的插件
```

### g) 生产环境配置文件总结 

```javascript
# 新建webpack.pub.config.js

const path = require("path")

const htmlWebpackPlugin = require('html-webpack-plugin');
const {CleanWebpackPlugin } = require('clean-webpack-plugin');
const ExtractTextPlugin = require("extract-text-webpack-plugin");
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');

module.exports = {
    //生产环境
    mode:"production",
    entry: path.join(__dirname, './src/main.js'),
    output: {
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js'
    },
    plugins: [ 
        // 添加plugins节点配置插件
        new htmlWebpackPlugin({
            template:path.resolve(__dirname, 'src/index.html'),//模板路径
            filename:'index.html',//自动生成的HTML文件的名称
            //压缩合并html页面
            minify: {
                collapseWhitespace: true, // 合并多余的空格
                removeComments: true, // 移除注释
                removeAttributeQuotes: true // 移除属性上的双引号
            }
        }),
        //每次发布项目的时候自动清除之前的dist目录
        new CleanWebpackPlugin (),
        new ExtractTextPlugin("css/styles.css"),
        new OptimizeCssAssetsPlugin() // 压缩CSS文件的插件
    ],
    module: { 
        rules: [
          { test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' }, 
          { test: /\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/ },
          {
            test: /\.css$/, use: ExtractTextPlugin.extract({
                fallback: "style-loader",
                use: ["css-loader"],
                publicPath: '../'         // 设置css背景图片的路径
            })
          },
          {
            test: /\.scss$/, use: ExtractTextPlugin.extract({
                fallback: "style-loader",
                use: [
                    {
                        loader: 'css-loader',
                        options: {
                            modules: {
                            localIdentName: '[path][name]__[local]--[hash:base64:5]'
                            }
                        }
                    },
                    {
                        loader: 'sass-loader',
                    }
                ],
                publicPath: '../'         // 设置css背景图片的路径
            })
          },
          {
            test: /\.less$/, use: ExtractTextPlugin.extract({
                fallback: "style-loader",
                use: [
                    {
                        loader: 'css-loader',
                        options: {
                            modules: {
                            localIdentName: '[path][name]__[local]--[hash:base64:5]'
                            }
                        }
                    },
                    {
                        loader: 'less-loader',
                    }
                ],
                publicPath: '../'         // 设置css背景图片的路径
            })
          },

          //name=images/[hash:8]-[name].[ext]   发布项目的时候把图片都放到images文件夹下面去
          { test: /\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&name=images/[hash:8]-[name].[ext]' },
        ]
    },
    resolve: {
        extensions: ['.js', '.jsx', '.json'], // 表示这几个文件的后缀名，可以省略不写
        alias: {
            '@': path.join(__dirname, './src')
        }
    },
    optimization: {
        //分割代码块
        splitChunks: {
            cacheGroups: {
                //自己写的代码打包 一个文件
                commons: {
                    name: "commons",
                    chunks: "initial",
                    //在分割之前，这个代码块最小应该被引用的次数
                    minChunks: 1,
                    //形成一个新代码块最小的体积
                    minSize: 0
                },
                //node_modules代码打包 一个文件
                vendor: {
                    chunks: "all",
                    test: /[\\/]node_modules[\\/]/,
                    name: "vendor",
                    minChunks: 1,
                    //入口最大的并行请求数
                    maxInitialRequests: 5,
                    // //形成一个新代码块最小的体积
                    minSize: 0,
                    //缓存组打包的先后优先级
                    priority: 100
                }
            }
        }
    },
}

#package.json中新增
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot",
    "pub": "webpack --config webpack.publish.config.js"
  }
```

# 6. React 事件处理

https://reactjs.org/docs/events.html

## 6.1 事件绑定

1. 事件的名称都是React的提供的，因此名称的首字母必须大写`onClick`、`onMouseOver`

2. 为事件提供的处理函数，必须是如下格式 

   ```javascript
   <button onClick={ function }>按钮</button>
   ```

3. 事件绑定方式：

   ```jsx
   #1.方式1：普通函数绑定
   <button onClick={ this.show }>按钮</button>

   // 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称
   function show(){
       console.log("show方法")
       console.log(this)   //undefined
   }

   #2.方式2：箭头函数绑定(此种方式用的比较多)
   <button onClick={ () => this.show('传参') }>按钮</button>

   // 事件的处理函数，需要定义为 一个箭头函数，然后赋值给函数名称
   show = (arg1) => {
       console.log('show方法' + arg1)
       console.log(this)   //当前组件对象
   }
   ```



> 注意点：
>
> 1.在react中，箭头函数中的this就代表当前的组件对象，因为箭头函数的this其实质是定义函数时所在作用域中的this。
>
> 2.在react中，普通函数中的this是undefined。

## 6.2 修改事件的this并传递参数

```javascript
#方式1：使用bind修改普通函数中的this指向
import React, {Component} from 'react'

class Test extends React.Component {
    constructor (props) {
        super(props)
        this.state = {message: 'Allo!'}
    }

    handleClick (name, e) {
        console.log(this.state.message + name)
    }

    render () {
        return (
            <div>
                <button onClick={ this.handleClick.bind(this, '赵四') }>Say Hello</button>
            </div>
        )
    }
}


#方式2.在构造函数中通过bind修改this指向，返回新函数，然后在render中使用修改this指向后的新函数
import React, {Component} from 'react'

class Test extends React.Component {
    constructor (props) {
        super(props)
        this.state = {message: 'Allo!'}
        this.handleClick = this.handleClick.bind(this)
    }

    handleClick (e) {
        console.log(this.state.message)
    }

    render () {
        return (
            <div>
                <button onClick={ this.handleClick }>Say Hello</button>
            </div>
        )
    }
}


#方式3：使用箭头函数
class Test extends React.Component {
    constructor (props) {
        super(props)
        this.state = {message: 'Allo!'}
    }

    handleClick = (e) => {
        console.log(this.state.message)
    }

    render () {
        return (
            <div>
                <button onClick={ this.handleClick }>Say Hello</button>
            </div>
        )
    }
}


#注意：第二种和第三种方式如果这样用，<button onClick={ this.handleClick() }>Say Hello</button> ，此时会直接调用handleClick函数。如果想要点击按钮的时候才触发handleClick方法并且要给this.handleClick函数中传递参数，可以使用箭头函数<button onClick={ ()=>{this.handleClick('aa','bb')} }>Say Hello</button>。但一旦使用了箭头函数，那么箭头函数中的this就已经指向了当前的组件对象
```

## 6.3 绑定文本框与state中的值

1. 在Vue中提供了`v-model`指令，可以很方便的实现 `数据的双向绑定`；

2. 但是在React中只是`单向数据流`，也就是只能把state上的数据绑定到页面，无法把页面中数据的变化自动同步回 state ； 如果需要把页面上数据的变化保存到 state，则需要程序员手动监听`onChange`事件，拿到最新的数据，手动调用`this.setState({  })` 更改回去。 这种方式叫受控组件



### 6.3.1 受控组件

	受控组件又称为智能组件，顾名思义受控组件就是受到控制的组件，受控组件是数据的所有者，它拥有数据、且拥有操作数据的action。它可以使用自己的state数据，也可以将数据和操作action传递给子组件，让子组件来完成UI或者功能。
	
	比如在表单的input中，我们给input的value值为state.inputValue时，当用户对input进行操作时，没有对inputValue进行setState()操作，这个值不变，也就意味着input显示不变。
	
	但是如果我们给input一个事件，在事件中进行对state的修改。每当用户输入时，input触发onChange事件，调用inputChange函数修改了value值。使用受控组件，每个状态的改变都有一个与之相关的处理函数。好处是可以直接修改或验证用户输入。

```javascript
//如果文本框没有指定onChange事件，那么该文本框是只读的，不可以修改
render() {
    return (
        <input value="this.state.value" onChange={this.inputChange}/>
    )
}

inputChange = e => this.setState({value: e.target.value})  
```

### 6.3.2 非受控组件

	函数组件又称为“无状态组件”，“非受控组件”或“木偶组件”。非受控组件不同于受控组件，它自身并不能拥有可改变的数据。因为函数组件只负责接收 props 并返回 UI，在真实的 React 应用开发场景下，我们经常尽可能的使用函数组件，将整个应用的 UI 拆分成尽可能小的视觉单元。

```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
 
  handleSubmit(event) {
    alert('A name was submitted: ' +this.refs.mytxt.value);
    event.preventDefault();
  }
 
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref="mytxt" />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}

  //和 Vue 中差不多，Vue 为页面上的元素提供了 ref 的属性，如果想要获取元素引用，则需要使用this.$refs.name
  //在 React 中也有 ref， 如果要获取元素的引用this.refs.引用名称
```

	受控组件和非受控组件这种编程思想非常重要，开发大型项目时体现的尤为明显，当项目很大时更需要把非受控组件细分，不然代码会杂乱无章，非常的不便于阅读，及其的不利于维护和扩展，最后的结果是项目无法进行。

### 6.3.3 React.createRef的使用

```javascript
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创造一个 textInput DOM 元素的 ref
    this.textInput = React.createRef();
  }
  render() {
  // 使用 `ref` 回调函数以在实例的一个变量中存储文本输入 DOM 元素
  //（比如，this.textInput）。
    return (
      <input
        type="text"
        ref={this.textInput}
      />
    );
  }
  
   // 使用原始的 DOM API 显式地聚焦在 text input 上
   // 注意：我们通过访问 “current” 来获得 DOM 节点
   this.textInput.current.focus();
}
```

### 6.3.4 ref回调

```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
 
  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.value);
    event.preventDefault();
  }
 
  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={(input) => this.input = input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
} 
```

### 6.3.5 ref转发

	Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。

```javascript
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// 你可以直接获取 DOM button 的 ref：
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;


/*
    以下是对上述示例发生情况的逐步解释：
1.我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。
2.我们通过指定 ref 为 JSX 属性，将其向下传递给 <FancyButton ref={ref}>。
3.React 传递 ref 给 fowardRef 内函数 (props, ref) => ...，作为其第二个参数。
4.我们向下转发该 ref 参数到 <button ref={ref}>，将其指定为 JSX 属性。
5.当 ref 挂载完成，ref.current 将指向 <button> DOM 节点。
*/
```



## 6.4 评论列表发表评论

```javascript
#1.CmtList.jsx
import React from 'react'
import CMTItem from './CmtItem.jsx'
import CMTBox from './CmtBox.jsx'

// 评论列表组件
export default class CMTList extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      list: [
        { user: 'zs', content: '123' },
        { user: 'ls', content: 'qqq' },
        { user: 'xiaohong', content: 'www' }
      ]
    }
  }

  // 在组件尚未渲染的时候，就立即获取数据
  componentWillMount() {
    this.loadCmts()
  }

  render() {
    return <div>
      <h1>这是评论列表组件</h1>

      {/* 发表评论的组件 */}
      {/* react 中，只要是传递给子组件的数据，不管是普通的数据还是方法，子组件都使用this.props来接收 */}
      <CMTBox reload={this.loadCmts}></CMTBox>
      <hr />

      {/* 循环渲染一些评论内容组件 */}
      {this.state.list.map((item, i) => {
        return <CMTItem key={i} {...item}></CMTItem>
      })}
    </div>
  }

  // 从本地存储中加载 评论列表
  loadCmts = () => {
    var list = JSON.parse(localStorage.getItem('cmts') || '[]')
    this.setState({
      list
    })
  }
}

#2.CmtItem.jsx
import React from 'react'

// 评论列表项组件
export default class CMTItem extends React.Component {

  render() {
    return <div style={{ border: '1px solid #ccc', margin: '10px 0' }}>
      <h3>评论人：{this.props.user}</h3>
      <h5>评论内容：{this.props.content}</h5>
    </div>
  }
}

#3.CmtBox.jsx
import React from 'react'

// 评论列表框组件
export default class CMTBox extends React.Component {

  render() {
    return <div>
      <label>评论人：</label><br />
      <input type="text" ref="user" /><br />
      <label>评论内容：</label><br />
      <textarea cols="30" rows="4" ref="content"></textarea><br />

      <input type="button" value="发表评论" onClick={this.postComment} />
    </div>
  }

  postComment = () => {
    // 1. 获取到评论人和评论内容
    // 2. 从本地存储中先获取评论数组
    // 3. 把 最新的这条评论，unshift 进去
    // 4. 在把最新的评论数组，保存到本地存储中
    var cmtInfo = { user: this.refs.user.value, content: this.refs.content.value }
    var list = JSON.parse(localStorage.getItem('cmts') || '[]')
    list.unshift(cmtInfo)
    localStorage.setItem('cmts', JSON.stringify(list))

    this.refs.user.value = this.refs.content.value = ''
    //在子组件中触发父组件的方法
    this.props.reload()
  }
}
```

# 7 React组件的通信

## 7.1 父子组件的通信

### a) 父组件传递给子组件

```javascript
//父组件
<CMTItem key={i} {...item}</CMTItem>

//子组件通过this.props可以获取到父组件传递过来的数据
```

### b) 子组件传递给父组件

```javascript
//父组件
 <CMTBox reload={this.loadCmts}></CMTBox>

//子组件通过this.props.reload() 来调用父组件的方法，调用的时候可以传递参数
```

## 7.2 父组件使用Context特性

	当你不想在组件树中通过逐层传递      `props`或者`state`的方式来传递数据时，可以使用`Context`来实现**跨层级**的组件数据传递。

### a) 父子组件传递数据的方式

![1553135155547](assets\1553135155547.png)

### b) 使用Context跨级传递数据

![1553135231745](assets\1553135231745.png)

```javascript
// 最外层的父组件
import PropTypes from 'prop-types';
export default class Com1 extends React.Component {
    constructor(props) {
        super(props)

        this.state = {
            color: 'red'
        }
    }

    // 1. 在父组件中定义一个function叫做getChildContext ，方法内部返回的对象就是要共享给所有子孙组件的数据
    getChildContext() {
        return {
            color: this.state.color
        }
    }

    // 2. 使用属性校验规定一下传递给子组件的数据类型，需要是静态方法
    static childContextTypes = {
        color: PropTypes.string
    }

    render() {
        return <div>
            <h1>这是 父组件 </h1>
            <Com2></Com2>
        </div>
    }
}


// 中间的子组件
class Com2 extends React.Component {
    render() {
        return <div>
            <h3>这是 子组件 </h3>
            <Com3></Com3>
        </div>
    }
}


// 内部的孙子组件
import PropTypes from 'prop-types';
class Com3 extends React.Component {

    // 3. 子组件在使用父组件context数据的时候首先需要对父组件传递过来的数据做类型校验
    static contextTypes = {
        color: PropTypes.string 
    }

    render() {
        return <div>
            <h5 style={{ color: this.context.color }}>这是 孙子组件  ---  {this.context.color} </h5>

    </div>
    }
}
```

### c) prop-types使用

```javascript
import PropTypes from 'prop-types';

MyComponent.propTypes = {
  // 你可以声明一个 prop 是一个特定的 JS 原始类型。 默认情况下，这些都是可选的。
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  // 任何东西都可以被渲染:numbers, strings, elements,数组或者是包含这些类型的片段。
  optionalNode: PropTypes.node,

  // 一个 React 元素  例如 <MyComponent />
  optionalElement: PropTypes.element,

  // 你也可以声明一个 prop 是类的一个实例。 
  // 使用 JS 的 instanceof 运算符。
  optionalMessage: PropTypes.instanceOf(Message),

  // 你可以声明 prop 是特定的值，类似于枚举
  optionalEnum: PropTypes.oneOf(['News', 'Photos']),

  // 一个对象可以是多种类型其中之一
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),

  // 一个某种类型的数组
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

  // 属性值为某种类型的对象
  optionalObjectOf: PropTypes.objectOf(PropTypes.number),

  // 一个特定形式的对象
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),

  // 你可以使用 `isRequired' 链接上述任何一个，以确保在没有提供 prop 的情况下显示警告。
  requiredFunc: PropTypes.func.isRequired,

  // 任何数据类型的值
  requiredAny: PropTypes.any.isRequired,
}
```

# 8. React组件的生命周期

## 8.1 生命周期钩子函数介绍

- 生命周期的概念：每个组件的实例，从创建、运行、到销毁，在这个过程中会出发一些列事件，这些事件就叫做组件的生命周期函数；

- React组件生命周期分为三部分：

  - **组件创建阶段**：

  > static 开头的     只会执行一次
  >
  > constructor    构造器     只会执行一次
  >
  > getDerivedStateFromProps: 当子组件接收到新的props会执行，作用：将传递的props映射到state里面   
  >
  >                                                    会执行多次
  >
  > render           构建虚拟dom，但是此时虚拟dom还没有渲染到页面        会执行多次
  >
  > componentDidMount:组建的虚拟dom已经挂载到页面                      只会执行一次

  - **组件运行阶段**：根据 props 属性 或 state 状态的改变，有选择性的执行0到多次

  > getDerivedStateFromProps:组件将要接收到新的props属性
  >
  > shouldComponentUpdate:组件是否需要被更新，返回值是true或者false。此时可以获取最新的props和state数据
  >
  > render: 重新更新渲染组件的虚拟dom
  >
  > getSnapshotBeforeUpdate：在最近一次渲染提交到 DOM 节点之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置），返回值将作为参数传递给componentDidUpdate
  >
  > componentDidUpdate: 组件完成了更新，此时页面已经是最新的了

  - **组件销毁阶段**：只执行一次

  > componentWillUnmount: 组件将要被销毁，此时组件还可以被使用
  >
  > ![1574654437154](assets/1574654437154.png)

React生命周期的回调函数总结成表格如下：
![1574666830021](assets/1574666830021.png))

## 8.2 生命周期函数详解及defaultProps、类型校验

> 在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。

```javascript
#1.Counter.jsx
import React from 'react'
import ReactTypes from 'prop-types'


class Counter extends React.Component {
    //----------------------------组件的创建阶段------------------------------------------
    //1.生命周期第一个执行的是静态属性(只会执行一次)
    //  静态属性：设置props的初始值(在使用当前组件的时候，没有给当前组件传递props的时候，该初始值会生效)
    static defaultProps = {
        initcount: 1000
    }
    static propTypes = {
        // 使用 prop-types 包 来定义 initcount 为 number 类型
        // isRequired 表示这个props属性是必须要传递的
        initcount: ReactTypes.number.isRequired
    }

    //2.生命周期第二个执行的是constructor 构造函数 (执行一次)
    // 在创建组件对象的时候会自动调用构造函数
    constructor(props) {
        console.log("constructor")
        super(props)
        //在构造函数中指定组件的私有数据
        this.state = {
            count: props.initcount
        }
        this.divRef = React.createRef()
    }
	
    //3.当子组件接收到新的props会执行(执行多次)
	 `注意：在react16.4版本以后，setState修改state数据触发forceUpdate方法之后也会触发这个方法
           此时当我们在componentDidUpdate方法中通过this.setState()方法修改state数据之后会导致页面没有更新的bug，对应此bug，我们可以给state新增prevCount字段来解决
     `
    // 在该方法中不能通过this.setSate来修改state数据,因为在staic修饰的方法中就没有this
    //作用：将传递的props映射到state里面
    //参数： nextProps 外部传递过来的props属性
    //      prevState 之前的state状态
    static getDerivedStateFromProps(nextProps, prevState) {
        console.log("getDerivedStateFromProps", nextProps, prevState)
        //获取到父组件中传递过来的initcount值
        const { initcount } = nextProps;
        //当父组件中传递过来的initcount发生改变了
        if (initcount != prevState.prevCount) {
            //在方法中返回{count:initcount} 替换掉当前state中的 count值
            return {
                count: initcount,
                prevCount:initcount
            }
        }
        //如果父组件中传递过来的initcount没有变化，就返回一个空对象(此时不对当前的state做任何修改)
        return null
    }

    //4.创建虚拟dom，但是虚拟dom还没有挂载到页面 (执行多次)
    // render函数中不能使用setState()来修改state的数据，因为会死循环
    render() {
        console.log("render", this.divRef.current)  //null
        return (<div ref={this.divRef}>
            哈哈Counter {this.state.count}
        </div>)
    }

    //5.虚拟dom已经挂载到页面，此时可以获取到最新的页面 (执行一次)
    componentDidMount() {
        console.log("componentDidMount", this.divRef.current, this.state)  //null
    }


    //----------------------------组件的运行阶段(执行多次)----------------------------
    // 第一个会执行：static getDerivedStateFromProps
    // 当父组件给子组件传递的props发生变化的时候，会执行该方法。
    // 在react16.4版本以后，当前组件的state发生变化，会触发forceUpdate方法，然后还是会触发该方法

    // 第二个会执行: shouldComponentUpdate
    // 在这个函数中，我们可以设置指定条件下去更新页面，指定条件下不更新页面。这个函数中入参props和state都是最新的
    // 在该方法中不能通过this.setSate来修改state数据
    shouldComponentUpdate(nextProps, nextState) {
        console.log("shouldComponentUpdate", nextProps, nextState)
        // 在 shouldComponentUpdate 中要求必须返回一个布尔值
        // 在 shouldComponentUpdate 中，如果返回的值是 false，则不会继续执行后续的生命周期函数，而是直接退回到了运行中的状态，此时后续的render函数并没有被调用，因此页面不会被更新，但是组件的 state 状态，却被修改了；
        // return nextState.count % 2 == 0 ? true : false;
        return true;
    }

    //第三个会执行:render  此时会重新构建虚拟dom，但是新的虚拟dom还没有渲染到页面

    //第四个会执行getSnapshotBeforeUpdate 函数
    // 在该方法中不能通过this.setSate来修改state数据
    getSnapshotBeforeUpdate() {
        console.log("getSnapshotBeforeUpdate")
        return {}
    }

    //第五个执行componentDidUpdate 函数
    // 在该方法中不能通过this.setSate来修改state数据
    //表示组件已经更新完毕  此时可以获取到最新的页面
    componentDidUpdate() {
        console.log("componentDidUpdate", this.state)
    }

    //-------------------组件的销毁阶段--------------------------
    componentWillUnmount() {
        console.log("componentWillUnmount")
    }
}

export default Counter;



#App.jsx
import React from 'react'

import Counter from '@/components/Counter'

class App2 extends React.Component {
    constructor() {
        super();

        this.state = {
            num:11
        }
    }

    handlerClick=()=>{
        this.setState({
            num:111
        })
    }

    render() {
        return (<div>
             App2
             <Counter initcount={this.state.num}></Counter>
             <button onClick={this.handlerClick}>点我该</button>
        </div>)
    }
}

export default App2;
```

## 8.3 getSnapshotBeforeUpdate方法

```javascript
#1.SnapshotSample.jsx
import React from 'react'
import cssobj from './snap.less'

class SnapshotSample extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            messages: [],//用于保存子div
        }
    }

    handleMessage() {//用于增加msg
        this.setState(pre => ({
            messages: [`msg: ${pre.messages.length}`, ...pre.messages],
        }))
    }
    componentDidMount() {
        for (let i = 0; i < 20; i++) this.handleMessage();//初始化20条
        this.timeID = window.setInterval(() => {//设置定时器
            if (this.state.messages.length > 200) {//大于200条，终止
                window.clearInterval(this.timeID);
                return;
            } else {
                this.handleMessage();
            }
        }, 1000)
    }
    componentWillUnmount() {//清除定时器
        window.clearInterval(this.timeID);
    }

    //很关键的，我们获取当前rootNode的scrollHeight，传到componentDidUpdate 的参数perScrollHeight
    //在render方法调用之后，在componentDidUpdate之前执行，我们可以在这个方法中获取到元素的滚动位置的信息
    //还可以在该方法中做一些样式的微调
    getSnapshotBeforeUpdate() {
        //console.log(this.rootNode.clientHeight)
        //this.rootNode.style.backgroundColor = "red";
        return this.rootNode.scrollHeight;
    }
    componentDidUpdate(perProps, perState, perScrollHeight) {
        const curScrollTop = this.rootNode.scrollTop;
        if (curScrollTop < 5) return;
        this.rootNode.scrollTop = curScrollTop + (this.rootNode.scrollHeight - perScrollHeight);
        //加上增加的div高度，就相当于不动
    }
    render() {
        return (
            <div className={cssobj.wrap} ref={node => (this.rootNode = node)} >
                {this.state.messages.map(msg => (
                    <div key={msg}>{msg} </div>
                ))}
            </div>
        );
    }
}

export default SnapshotSample;


#2.snap.less
.wrap{
    height: 100px;
    width :200px;
    padding: 1px solid #eee;
    overflow:auto;
}


#3.App.jsx
import React from 'react'

import SnapshotSample from '@/components/SnapshotSample'

class App2 extends React.Component {
    constructor() {
        super();

        this.state = {
            num:11
        }
    }

    handlerClick=()=>{
        this.setState({
            num:111
        })
    }

    render() {
        return (<div>
             App2
             <SnapshotSample></SnapshotSample >
        </div>)
    }
}

export default App2;
```

# 9. React-router

## 9.1 前端路由的两种实现方案

1. hash : hash原本的作用是为一个很长的文档页添加锚点信息，它自带不改变url刷新页面的功能，所以自然而然被用单页面应用程序中了。

2. history : 应该说history是主流的解决方案，浏览器的前进后退用的就是这个，它是window对象下的，以前的history提供的方法只能做页面之间的前进后退，如下：

   ```javascript
   history.go(number|URL) 可加载历史列表中的某个具体的页面
   history.forward() 可加载历史列表中的下一个 URL
   history.back() 可加载历史列表中的前一个 URL
   ```

   为了在不刷新浏览器的情况下，创建新的浏览记录并插入浏览记录队列中，html5新增了如下方法：

   ```
   1. history.pushState(state, title, url)
      添加一条历史记录， state用于传递参数，可以为空。title是设置历史记录的标题，可以为空。url是历史记录的URL，不可以为空。

   2.history.replaceState(state, title, url)
   将history堆栈中当前的记录替换成这里的url，参数同上。

   这个特性后来用到了单页面应用中比如：vue-router，react-router-dom里面。
   ```

## 9.2 Reac中的路由

	`<Router>`是React中实现路由最外层的容器，一般情况下我们不再需要直接使用它，而是使用在它基础之上封装的几个适用于不同环境的组件，react-router-dom的Router有四种：

| Router                                                       | 适用情况                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [BrowserRouter](https://link.jianshu.com?t=https%3A%2F%2Freacttraining.com%2Freact-router%2Fweb%2Fapi%2FBrowserRouter) | react-router-dom扩展，利用HTML5 新增的history API (pushState, replaceState)，是web应用最常用的路由组件 |
| [HashRouter](https://link.jianshu.com?t=https%3A%2F%2Freacttraining.com%2Freact-router%2Fweb%2Fapi%2FHashRouter) | react-router-dom扩展，利用window.location.hash，适用于低版本浏览器或者一些特殊情境 |
| [MemoryRouter](https://link.jianshu.com?t=https%3A%2F%2Freacttraining.com%2Freact-router%2Fweb%2Fapi%2FMemoryRouter) | 继承自react-router ，用户在地址栏看不到任何路径变化，一般用在测试或者非浏览器环境开发中 |
| [StaticRouter](https://link.jianshu.com?t=https%3A%2F%2Freacttraining.com%2Freact-router%2Fweb%2Fapi%2FStaticRouter) | 继承自react-router，某些页面从渲染出来以后没有多的交互，所以没有状态的变化需要存储，就可以使用静态路由，静态路由适用于服务器端 |

	一般我们很少会用到MemoryRouter和StaticRouter，在web应用中更多的是用   `react-router-dom`扩展出来的BrowserRouter和HashRouter，这两个就是我前面提到的前端路由的两种解决办法的各自实现。

## 9.3 HashRouter的基本使用

```javascript
npm install react-router-dom -S

#1.main.js 
// 1. 导入包
import React from 'react'
import ReactDOM from 'react-dom'

import App from './App.jsx'

// 使用 render 函数渲染 虚拟DOM
ReactDOM.render(<App></App>, document.getElementById('app'))
                

#2.App.jsx
import React from 'react'

// HashRouter 表示一个路由的跟容器，所有的路由相关的东西，都要包裹在 HashRouter 里面
// Route 表示一个路由规则， 在 Route 上有两个比较重要的属性：path   component
// Link 表示一个路由的链接 ，就好比 vue 中的 <router-link to=""></router-link>
import { HashRouter, Route, Link } from 'react-router-dom'

import Home from './components/Home.jsx'
import Movie from './components/Movie.jsx'
import About from './components/About.jsx'

export default class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {}
  }

  render() {
    // 当 使用 HashRouter 把 App 根组件的元素包裹起来之后，网站就已经启用路由了
    // 在一个 HashRouter 中，只能有唯一的一个根元素
    // 在一个网站中，只需要使用 唯一的一次 <HashRouter></HashRouter> 就行了
    return <HashRouter>
      <div>
        <h1>这是网站的APP根组件</h1>
      
        <Link to="/home">首页</Link>&nbsp;&nbsp;
        <Link to="/movie/top250/10">电影</Link>&nbsp;&nbsp;
        <Link to="/about">关于</Link>

        <hr />

        {/* Route 创建的标签，就是路由规则，其中 path 表示要匹配的路由，component 表示要展示的组件 */}
        {/* 在 vue 中有个 router-view 的路由标签专门用来放置匹配到的路由组件的，但是在 react-router 中并没有类似于这样的标签，而是直接把 Route 标签当作的坑（占位符） */}
        {/* Route 具有两种身份：1. 它是一个路由匹配规则； 2. 它是一个占位符，表示将来匹配到的组件都放到这个位置， 如果想让路由规则进行精确匹配，可以为 Route添加 exact 属性，表示启用精确匹配模式 */}
        <Route path="/home" component={Home}></Route>

        <hr />

        {/* 注意：默认情况下，路由中的规则是模糊匹配的，如果路由可以部分匹配成功，就会展示这个路由对应的组件 */}
        {/* 如果要匹配参数，可以在匹配规则中使用 : 修饰符，表示这个位置匹配到的是参数 */}
        <Route path="/movie/:type/:id" component={Movie} exact></Route>

        <hr />

        <Route path="/about" component={About}></Route>
      </div>
    </HashRouter>
  }
}

#3.components/Home.jsx    
import React from 'react'

export default class Home extends React.Component {
  constructor(props) {
    super(props)
    this.state = {}
  }

  render() {
    return <div>
      Home
    </div>
  }
}



#4. components/Movie.jsx 
import React from 'react'

export default class Movie extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      routeParams: props.match.params
    }
  }

  render() {
    console.log(this);
    // 如果想要从路由规则中，提取匹配到的参数进行使用，可以使用 this.props.match.params.*** 来访问
    return <div>
      {/* Movie --- {this.props.match.params.type} --- {this.props.match.params.id} */}

      Movie --- {this.state.routeParams.type} --- {this.state.routeParams.id}

    </div>
  }
}


#5. components/About.jsx
import React from 'react'

export default class About extends React.Component {
  constructor(props) {
    super(props)
    this.state = {}
  }

  render() {
    return <div>
      About
    </div>
  }
}
```

## 9.4 匹配规则

**默认：**

| 路径 | location.pathname | 是否匹配 |
| ---- | ----------------- | -------- |
| /one | /one              | 是       |
| /one | /one/             | 是       |
| /one | /one/111          | 是       |
| /one | /one/aaa/bbb      | 是       |

**exact配置：**exact属性为true时路径中的hash值必须和path完全一致才渲染对应的组件，如果为false则'/'也可以匹配'/xxx'

| 路径 | location.pathname | exact | 是否匹配 |
| ---- | ----------------- | ----- | -------- |
| /one | /one/two          | true  | 否       |
| /one | /one/two          | false | 是       |

**strict配置：**strict属性主要就是匹配反斜杠，规定是否匹配末尾包含反斜杠的路径，如果strict为true，则如果path中不包含反斜杠结尾，则他也不能匹配包含反斜杠结尾的路径

| 路径  | location.pathname | strict | 是否匹配 |
| ----- | ----------------- | ------ | -------- |
| /one/ | /one              | true   | 否       |
| /one/ | /one/             | true   | 是       |
| /one/ | /one/two          | true   | 是       |

## 9.5 Switch和Redirect

```javascript
import { HashRouter, Route, Link, Switch,Redirect} from 'react-router-dom'

render() {
        return (
            <HashRouter>
                {/*
                Switch表示路由互斥，如果没有Switch，会根据路由找到所有匹配的组件显示
                比如http://localhost:3000/#/user  会找到/、/user所匹配的路由(下面home没有找到是因为精确匹配了)
                */}
                <Switch>
                    {/*
                    path:/ 表示访问根路径的情况下默认载入home组件
                    exact精确匹配，为了给其他组件一个机会获取到url改变
                    */}
                    <Route path='/' exact  component={Home}/>
                    <Route path='/city' component={City}/>
                    {/*
                    strict 在确定路径是否与当前URL匹配时，将考虑路径后的斜线；
                    */}
                    <Route path='/login/' strict component={Login}/>
                    <Route path='/user' component={User}/>
                    <Route path='/search/:category/' strict component={Search}/>
                    <Route path='/detail/:id' component={Detail}/>
                    {/*没有匹配到路径的时候重定向到根路径*/}
                    <Redirect to="/" />
                </Switch>
            </HashRouter>
        )
    }
```

## 9.6 React中的编程式导航和路由传参

### 9.6.1 withRouter的使用

	withRouter可以包装任何自定义组件，将react-router 的 history,location,match 三个对象传入。 

```javascript
 <Route exact path="/Home" component={Home}/>
 
 1.只有包裹在Route组件里的才能使用`this.props.location`，
 2.假如有个需求，是面包屑或者导航组件里需要拿到`this.props.location`（导航组件或者面包屑一般不会包裹在`Route`里吧），那么直接这么写显然就不行了。
 这个时候`withRouter`修饰一下，就可以这么写了。
```

### 9.6.2 使用withRouter跳转页面

```javascript
#关于this.props.history
在 React 中正常来说只有在 <Route> 包裹的组件中才能在 this.props 属性中找到 history 对象。但有些情况下我们就是希望在一个没被 <Route> 包裹的组件中用到 history 对象，我们可以这样用
import { withRouter } from 'react-router-dom'

export default withRouter(YourComponent)

//此时就可以在组件中使用this.props.history跳转路由了
this.props.history.push({pathname:"/path/"});
```

### 9.6.3 路由传参

#### a) params方式传参

```javascript
<Route path='/path/:name' component={Path}/>

<Link to="/path/2">xxx</Link>
this.props.history.push({pathname:"/path/" + name});

读取参数用:this.props.match.params.name
```

优势 ： 刷新地址栏，参数依然存在
缺点  :   只能传字符串，并且如果传的值太多的话，url会变得长而丑陋。

#### b) query方式传参

```javascript
<Route path='/query' component={Query}/>

<Link to={{ pathname : ' /query' , query : { name : 'sunny' }}}>
this.props.history.push({pathname:"/query",query: { name : 'sunny' }});

读取参数用: this.props.location.query.name
```

优势：传参优雅，传递参数可传对象；
缺点：刷新地址栏，参数丢失

#### c) state方式传参

```javascript
<Route path='/sort ' component={Sort}/>

<Link to={{ pathname : ' /sort ' , state : { name : 'sunny' }}}> 
this.props.history.push({pathname:"/sort ",state : { name : 'sunny' }});

读取参数用: this.props.location.state.name 
```

优势：传参优雅，传递参数可传对象，state传的参数是加密的
缺点：刷新地址栏，参数丢失

#### d) search方式传参

```javascript
<Route path='/web/departManange ' component={DepartManange}/>

<link to="web/departManange?tenantId=12121212">xxx</Link>
this.props.history.push({pathname:"/web/departManange?tenantId" + row.tenantId});

读取参数用: this.props.location.search
```

优势 ： 刷新地址栏，参数依然存在

缺点  :   只能传字符串，并且如果传的值太多的话，url会变得长而丑陋。

## 9.7 组件懒加载

`React.lazy` 函数能让你像渲染常规组件一样处理动态引入（的组件）。

如果在 `MyComponent` 渲染完成后，包含 `OtherComponent` 的模块还没有被加载完成，我们可以使用加载指示器为此组件做优雅降级。这里我们使用 `Suspense` 组件来解决。

```javascript
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import React, { Suspense, lazy } from 'react';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    //fallback 属性接受任何在组件加载过程中你想展示的 React 元素
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home}/>
        <Route path="/about" component={About}/>
      </Switch>
    </Suspense>
  </Router>
);
```

# 10.动画

https://blog.csdn.net/think_of_/article/details/79373989

https://zh-hans.reactjs.org/docs/animation.html

<http://react-cn.github.io/react/docs/animation.html>

React 提供了一个 `ReactTransitionGroup` 插件作为动画的底层API，和一个 `ReactCSSTransitionGroup` 用于轻松实现基础的CSS动画和过渡。

## 10.1 `ReactCSSTransitionGroup`基本使用

`ReactCSSTransitionGroup` 基于 `ReactTransitionGroup` 是一个当React组件进入或离开DOM时，执行CSS动画和过渡的简单方法。它的灵感来自于杰出的 [ng-animate](http://www.nganimate.org/) 库。

`ReactCSSTransitionGroup` 是 `ReactTransitions` 的接口实现。这是一个简单的元素，包裹了所有你感兴趣的动画组件。这里是一个淡入和淡出列表项目的例子。

```javascript
import React from 'react'
import '@/css/demo1.css'

export default class Demo1 extends React.Component{
    constructor(props){
        super(props);

        this.state = {
            items: ['hello', 'world', 'click', 'me']
        };
    }

    //渲染页面
    render(){
        var ReactCSSTransitionGroup = require('react-addons-css-transition-group');

        //items 得到 [<div>hello</div>,<div>world</div>,....]
        var items = this.state.items.map((item,i)=>{
            return (
              <div key={item} onClick={()=>{this.handleRemove({i})}}>
                 {item}
              </div>
            );
        });
          
        return (
            <div>
                {/*点击按钮执行添加*/}
                <button onClick={()=>{this.handleAdd()}}>Add Item</button>
                {/*把要动画的元素用ReactCSSTransitionGroup包裹起来*/}
                <ReactCSSTransitionGroup component="ul" transitionName="example"  transitionEnterTimeout={500} transitionLeaveTimeout={300}>
                   {items}
                </ReactCSSTransitionGroup>
            </div>
        );
    }

    //添加数据的方法
    handleAdd = ()=> {
        this.setState((state)=>{
            return {
                items:[prompt('Enter some text'),...state.items]
            }
        })
    }


    //移除数据的方法
    handleRemove = (i)=> {
        var newItems = this.state.items.slice();
        newItems.splice(i, 1);
        this.setState({items: newItems});
    }
}
```

> 注意:
>
> 你必须为`ReactCSSTransitionGroup`的所有子级提供 [ key 属性]()，即使只渲染一个项目。这就是React将决定哪一个子级进入、离开、停留

当一个新的项目被添加到 `ReactCSSTransitionGroup` ,他将得到 `example-enter` CSS类 并且在下一刻`example-enter-active` CSS类被添加。这是一个基于`transitionName` prop 的约定。

你可以使用这些类来触发CSS动画和过渡。比如，尝试添加这个CSS和添加一个新的列表项：

```javascript
//demo1.css

.example-enter {
  opacity: 0.01;
}

.example-enter.example-enter-active {
  opacity: 1;
  transition: opacity 500ms ease-in;
}

.example-leave {
  opacity: 1;
}

.example-leave.example-leave-active {
  opacity: 0.01;
  transition: opacity 300ms ease-in;
}
```

你会注意到动画持续时间需要被同时在CSS和渲染方法里被指定，这告诉React什么时候从元素中移除动画类，并且如果它正在离开何时从DOM移除元素。

## 10.2 让初始化挂载动画

`ReactCSSTransitionGroup` 提供了可选的prop `transitionAppear`，来为在组件初始挂载添加一个额外的过渡阶段。 通常在初始化挂载时没有过渡阶段因为`transitionAppear` 的默认值为`false`。下面是一个传递`transitionAppear` 为值`true`的例子。

```javascript
  render: function() {
    return (
      <ReactCSSTransitionGroup transitionName="example" transitionAppear={true} transitionAppearTimeout={500}>
        <h1>Fading at Initial Mount</h1>
      </ReactCSSTransitionGroup>
    );
  }
```

在初始化挂载时 `ReactCSSTransitionGroup` 将获得`example-appear` CSS类 并且`example-appear-active` CSS 类在下一刻被添加。

```javascript
.example-appear {
  opacity: 0.01;
}

.example-appear.example-appear-active {
  opacity: 1;
  transition: opacity .5s ease-in;
}
```

在初始化挂载，所有的 `ReactCSSTransitionGroup` 子级将会 `appear` 但不 `enter`。然而所有后来添加到已存在的 `ReactCSSTransitionGroup` 的子级将 `enter` 但不 `appear`。

> 注意:
>
> prop `transitionAppear` 在版本 `0.13` 被添加到 `ReactCSSTransitionGroup`。为了保持向后兼容，默认值被设置为 `false`。

## 10.3 制定类

可以为你的每一步过渡使用制定类名字。代理传递一个字符串到transitionName，你可以传递一个含有`enter` 或者`leave` 类名的对象，或者一个含有 `enter`, `enter-active`, `leave-active`, 和 `leave` 类名的对象。

```javascript
  ...
  <ReactCSSTransitionGroup
    transitionName={ {
      enter: 'enter',
      enterActive: 'enterActive',
      leave: 'leave',
      leaveActive: 'leaveActive',
      appear: 'appear',
      appearActive: 'appearActive'
    } }>
    {item}
  </ReactCSSTransitionGroup>
  ...
```

## 10.4 动画一个或者零个项目

在上面的例子中，我们渲染了一系列的项目到`ReactCSSTransitionGroup`里。然而 `ReactCSSTransitionGroup` 的子级同样可以是一个或零个项目，这使它能够动画化单个元素的进入和离开。同样你可以动画化一个新的元素替换当前元素。例如，我们可以像这样实现一个简单的图片轮播器：

```javascript
#参考课件中的图片轮播案例

var ReactCSSTransitionGroup = require('react-addons-css-transition-group');

var ImageCarousel = React.createClass({
  propTypes: {
    imageSrc: React.PropTypes.string.isRequired
  },
  render: function() {
    return (
      <div>
        <ReactCSSTransitionGroup transitionName="carousel" transitionEnterTimeout={300} transitionLeaveTimeout={300}>
          <img src={this.props.imageSrc} key={this.props.imageSrc} />
        </ReactCSSTransitionGroup>
      </div>
    );
  }
});
```

## 10.6 禁用动画

如果你想禁用 `enter` 或者 `leave` 动画。例如，有时你可能想要一个 `enter` 动画，不要 `leave` 动画，但是 `ReactCSSTransitionGroup` 会在移除你的DOM节点之前等待一个动画完成。你可以添加`transitionEnter={false}` 或者 `transitionLeave={false}` props 到 `ReactCSSTransitionGroup` 来禁用这些动画。

> 注意：
>
> 当使用 `ReactCSSTransitionGroup` 时，没有办法通知你的组件何时过渡效果结束或者在动画时执行任何复杂的逻辑运算。如果你想要更多细粒度的控制，你可以使用底层的 `ReactTransitionGroup` API，它提供了你自定义过渡效果所需要的挂钩。

## 10.7 渲染一个不同的组件

默认情况下 `ReactTransitionGroup` 渲染为一个 `span`。你可以通过提供一个 `component` prop 来改变这种行为。例如下面是你将如何渲染一个`<ul>`：

```javascript
<ReactTransitionGroup component="ul">
  ...
</ReactTransitionGroup>
```

每一个React能渲染的DOM组件都是可用的。然而组件不需要是一个DOM组件。它可以是任何你想要的React组件；甚至是你自己已经写好的！只要写 `component={List}` 你的组件会收到 `this.props.children`（组件的所有子节点）

## 10.8 React Spring动画库

<https://www.react-spring.io/docs/hooks/basics>

### 10.8.1 基本用法

	React Spring是使用于reactjs的动画工具库，因为依据 react-motio作者Cheng Lou的演讲观点95%以上的动画特效使用spring即可达到可用的效果，以往那种时间间隔和曲线的动画理念生硬又复杂。
	
	react-spring库中UseSpring和animated

	UseSpring是一个可以设置样式的自定义钩子，它接受一个对象，该对象具有from和to值作为开始和结束状态，react-spring正是用这两个状态来处理过渡的动画效果。from和to几乎可以设置所有的CSS属性对象：颜色，大小，transform，甚至滚动条。

	只需要在HTML标签上增加animated就可以应用spring动画。默认情况下，动画会在组件挂载的时候立即执行。

```javascript
    //1.改变透明度
    const animation = useSpring({
        from: { opacity: 0 },
        to: { opacity: 1 }
    });

    //2.改变颜色
    const colorAnimation = useSpring({
        config: { duration: 4000 },
        delay: 2000,
        from: { color: 'blue' },
        to: { color: `rgb(255,0,0)` },
        /*从from到to的过程开启动画*/
        reset: true,
        /*reverse:会自动反转from和to的值，这个值只有在联合reset:true的情况下才生效*/
        reverse: true,
        /*动画的回调函数*/
        onStart: () => { console.log("动画开始") },
        onRest: () => { console.log("动画停止") },
        onFrame: (v) => { console.log("动画过程中的回调函数", v) }
    });
    /*
    config的一些配置参数：
        mass：影响速度以及过渡的效果。
        tension：影响整体速度。
        friction：控制阻力及其减速的速度。
        clamp：是否应该瞬间过渡。
    
    官方提供的一些有用的预设值搭配：
        config.default { mass: 1, tension: 170, friction: 26 }
        config.gentle { mass: 1, tension: 120, friction: 14 }
        config.wobbly { mass: 1, tension: 180, friction: 12 }
        config.stiff { mass: 1, tension: 210, friction: 20 }
        config.slow { mass: 1, tension: 280, friction: 60 }
        config.molasses { mass: 1, tension: 280, friction: 120 }   
    */

    //3.改变透明度和颜色  多个状态改变
    const multiAnimation = useSpring({
        from: { opacity: 0, color: 'red' },
        to: [
            { opacity: 1, color: '#ffaaee' },
            { opacity: 1, color: 'red' },
            { opacity: .5, color: '#008000' },
            { opacity: .8, color: 'black' }
        ]
    });

     return (
        <div>
            <animated.h1 style={animation}>Hello World</animated.h1>
            <animated.h1 style={colorAnimation}>Hello World</animated.h1>
            <animated.h1 style={multiAnimation}>Hello World</animated.h1>
    )
```

```javascript
//案例---循环变动

#1.App.jsx
import React, { useState } from 'react'
import { useSpring, animated, interpolate } from 'react-spring';
import './app.css'

function App(props) {
    
    const animation = useSpring({
        from: { left: '0%', top: '0%', width: '0%', height: '0%', background: 'lightgreen' },
        to: async next => {
          while (1) {
            await next({ left: '0%', top: '0%', width: '100%', height: '100%', background: 'lightblue' })
            await next({ height: '50%', background: 'lightgreen' })
            await next({ width: '50%', left: '50%', background: 'lightgoldenrodyellow' })
            await next({ top: '0%', height: '100%', background: 'lightpink' })
            await next({ top: '50%', height: '50%', background: 'lightsalmon' })
            await next({ width: '100%', left: '0%', background: 'lightcoral' })
            await next({ width: '50%', background: 'lightseagreen' })
            await next({ top: '0%', height: '100%', background: 'lightskyblue' })
            await next({ width: '100%', background: 'lightslategrey' })
          }
        },
      })
      return <animated.div className="script-box" style={animation} />
}

export default App



#2.app.css
* {
    box-sizing: border-box;
  }
  
  html,
  body,
  #root {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: white;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  
  #app {
    background: #f0f0f0;
    overflow: hidden;
    position: relative;
    width: 100%;
    height: 100%;
  }
  
  .script-box {
    will-change: width, height, left, top;
    position: relative;
  }

```

### 10.8.2 interpolate的用法

	除了仅对元素和组件添加静态样式更改之外，我们还可以使用Interpolate创建更有趣和可重用的动画。 由于它也是一个对象，因此可以在spring中添加变量，并使用Interpolate获取样式。
	
	我们只需要从spring中取值，并使用Interpolate对其进行更多分解，将其放入模板中。 这将使我们能够自由设置更多的动态值。

 	Interpolate还有一个作用可以让我们模拟css的关键帧

```jsx
const { o, xyz, color } = useSpring({
        from: { o: 0, xyz: [0, 0, 0], color: 'red' },
        to: { o: 1, xyz: [10, 20, 5], color: 'green' }
    })
    
return (
        <div>
            {/*  Interpolate :允许我们提取变量值，转换成对应的动画样式
               Interpolate还有一个作用可以让我们模拟css的关键帧
            */}
            <animated.div
                style={{
                    color,
                    //改变背景色 o作为入参
                    background: o.interpolate(o => `rgba(210, 57, 77, ${o})`),
                    //改变transform xyz作为入参
                    transform: xyz.interpolate((x, y, z) => `translate3d(${x}px, ${y}px, ${z}px)`),
                    //直接调用interpolate方法可以合并多个值，这边border使用多个值来设定样式
                    border: interpolate([o, color], (o, c) => `${o * 10}px solid ${c}`),
                    /*关键帧:range对应动画的阶段，output对应每一个动画阶段的输出值*/
                    padding: o.interpolate({ range: [0, 0.5, 1], output: [0, 0, 10] }).interpolate(o => `${o}%`),
                    borderColor: o.interpolate({ range: [0, 1], output: ['red', '#ffaabb'] }),
                    /*关键帧：省略range和output*/
                    opacity: o.interpolate([0.1, 0.2, 0.6, 1], [1, 0.1, 0.5, 1])
                }}
            >
                {/*保留两位小数*/}
                {o.interpolate(n => n.toFixed(2))}
            </animated.div>
        </div>
    )
```

```javascript
//给组件传递数据  --- 进度条
#1.App.jsx
import Donut from '@/components/Donut'

const AnimatedDonut = animated(Donut)
const donutAnimation = useSpring({ value: 100, from: { value: 0 } })

return (
    <div>
    <AnimatedDonut percent={donutAnimation.value} />
    </div>
)


#2.Donut.jsx
import React from 'react'
import { useSpring, animated, interpolate } from 'react-spring';
import './dount.css'

export default function Donut(props) {
    const { width } = useSpring({ width: props.percent })

    return (<div className="main">
            <animated.div className="fill" style={{ width: width.interpolate(x => x + "%") }}>		</animated.div>
<animated.div className="content">{width.interpolate(x => x.toFixed(0))}</animated.div>
</div>)
}


#3.donut.css
.main{
    height: 50px;
    line-height: 50px;
    text-align: center;
    position: relative;
    width: 500px;
    color: red;
}

.main .fill{
    height: 100%;
    background: blue;
    border-radius: 10px;
    position: absolute;
    left: 0px;
    top: 0px;
}

.main .content{
    z-index: 999;
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
}
```



### 10.8.3 useSpring的用法

#### a) 通过state切换动画

```javascript
import React, { useState } from 'react'
import { useSpring, animated, interpolate } from 'react-spring';

function App(props) {
    //注意：react-spring只能在hooks中使用，hooks是函数组件的新特性
    //因此react-spring只能在函数组件中用，函数组件中要声明state，需要借助useState()来完成
    //注意点：函数组件中没有this


    //1.声明一个state
    const [flag, setFlag] = useState(false)

    //2.改变透明度动画 这边to的状态受到flag这个state控制
    const animation = useSpring({
        from: { opacity: 0 },
        to: { opacity: flag ? 1 : 0 }
    });

    return (
        <div>
            <animated.h1 style={animation}>Hello World</animated.h1>
            {/*点击按钮的时候切换state状态，从而切换动画*/}
            <button onClick={()=>{setFlag(state=>!state)}}>点我切换</button>
        </div>
    )
}

export default App
```

```jsx
//案例---点击翻转图片
#1.App.jsx
import React, { useState } from 'react'
import { useSpring, animated, interpolate } from 'react-spring';
import './app.css'

function App(props) {

    const [flipped, setFlipped] = useState(false)
    const { transform, opacity } = useSpring({
        opacity: flipped ? 1 : 0,
        transform: `perspective(600px) rotateX(${flipped ? 180 : 0}deg)`
    })
    return (
        <div onClick={() => setFlipped(state => !state)}>
            <animated.div className="c back" style={{ opacity: opacity.interpolate(o => 1 - o), transform }} />
            <animated.div className="c front" style={{ opacity, transform: transform.interpolate(t => `${t} rotateX(180deg)`) }} />
        </div>
    )
}

export default App



#2.app.css

html,
body,
#app {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  user-select: none;
  background: #f0f0f0;
}

#app > div {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.c {
  position: absolute;
  max-width: 500px;
  max-height: 500px;
  width: 50ch;
  height: 50ch;
  cursor: pointer;
  will-change: transform, opacity;
}

.front,
.back {
  background-size: cover;
}

.back {
  background-image: url(https://images.unsplash.com/photo-1544511916-0148ccdeb877?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1901&q=80i&auto=format&fit=crop);
}

.front {
  background-image: url(https://images.unsplash.com/photo-1540206395-68808572332f?ixlib=rb-1.2.1&w=1181&q=80&auto=format&fit=crop);
}
```

#### b) 手动切换动画

```javascript
import React, { useState } from 'react'
import { useSpring, animated, interpolate } from 'react-spring';

function App(props) {
    //1.useSpring()接收箭头函数，此时会返回一个数组
    //通过解构赋值获取到useSpring()函数返回的结果  animation表示动画属性，set可以用来修改动画属性，stop可以用来停止动画
    const [animation, set, stop] = useSpring(() => ({ opacity: 0 }))

    return (
        <div>
            {/*2.鼠标移入和移出改变透明度*/}
            <animated.div style={animation} onMouseOver={()=>{set({opacity:1})}} onMouseOut={()=>{set({opacity:0})}}>i will fade</animated.div>
        </div>
    )
}

export default App
```

```jsx
//案例-图层移动
#1.App.jsx
import React, { useState } from 'react'
import { useSpring, animated, interpolate } from 'react-spring';
import './app.css'

function App(props) {
    //根据鼠标位置计算相对于图片中心点的坐标
    const calc = (x, y) => [x - window.innerWidth / 2, y - window.innerHeight / 2]
    //不同的图片给于不同的动画函数
    const trans1 = (x, y) => `translate3d(${x / 10}px,${y / 10}px,0)`
    const trans2 = (x, y) => `translate3d(${x / 8 + 35}px,${y / 8 - 230}px,0)`
    const trans3 = (x, y) => `translate3d(${x / 6 - 250}px,${y / 6 - 200}px,0)`
    const trans4 = (x, y) => `translate3d(${x / 3.5}px,${y / 3.5}px,0)`

    //创建动画(这边只入参xy 然后再根据入参的xy计算每个div的动画属性)
    const [amimation, set] = useSpring(() => ({ xy: [0, 0], config: { mass: 10, tension: 550, friction: 140 } }))
    
    return (/*根据鼠标位置，计算xy*/
        <div className="container" onMouseMove={({ clientX: x, clientY: y }) => set({ xy: calc(x, y) })}>
            <animated.div className="card1" style={{ transform: amimation.xy.interpolate(trans1) }} />
            <animated.div className="card2" style={{ transform: amimation.xy.interpolate(trans2) }} />
            <animated.div className="card3" style={{ transform: amimation.xy.interpolate(trans3) }} />
            <animated.div className="card4" style={{ transform: amimation.xy.interpolate(trans4) }} />
        </div>
    )
}

export default App


#2.app.css
html,
body,
#app {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  background-color: white;
  overflow: hidden;
  background: #f0f0f0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, ubuntu,
    roboto, noto, segoe ui, arial, sans-serif;
  background: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  cursor: default;
}

.card1,
.card2,
.card3,
.card4 {
  position: absolute;
  border-radius: 5px;
  background-size: cover;
  background-position: center center;
  background-repeat: no-repeat;
  will-change: transform;
}

.card1 {
  min-width: 60ch;
  min-height: 60ch;
  width: 45vw;
  height: 45vw;
  max-width: 100ch;
  max-height: 100ch;
  background-image: url(https://image.flaticon.com/icons/svg/119/119596.svg);
}

.card2 {
  width: 25ch;
  height: 25ch;
  background-image: url(https://image.flaticon.com/icons/svg/789/789395.svg);
}

.card3 {
  opacity: 0.9;
  width: 25ch;
  height: 25ch;
  background-image: url(https://image.flaticon.com/icons/svg/414/414927.svg);
}

.card4 {
  width: 25ch;
  height: 25ch;
  background-image: url(https://image.flaticon.com/icons/svg/789/789392.svg);
}

.container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

```

### 10.8.4 useSprings的用法

	useSpring用来创建一个Spring，useSprings可以用来创建一组Spring，每个Spring都有自己的配置。

```jsx
import React from 'react'
import { useSprings, animated } from 'react-spring';

function App(props) {
    const items = [0.2, 0.4, 0.6, 0.8, 1.0];
    const springs = useSprings(5, items.map(item => ({ from: { opacity: 0 }, to: { opacity: item } })))
    return springs.map((p, idx) => <animated.div key={idx} style={p}>哈哈</animated.div>)
}

export default App
```

### 10.8.5 useTrail的用法

useTrail可以用来创建一组Spring，每个Spring都有相同的配置，每个Spring跟随前一个Spring，在交叉的动画中使用

```jsx
import React from 'react'
import { useTrail, animated } from 'react-spring';

function App(props) {
    //这种写法可以
    //const trail = useTrail(5, {opacity: 1})

    //这种写法也可以
    const [trail, set, stop] = useTrail(5, () => ({ opacity: 1 }))

    return (<div>
        {trail.map((p, idx) => <animated.div key={idx} style={p} >哈哈</animated.div>)}
        <button onClick={() => { set({ opacity: 0 }) }}>点我改变透明度</button>
    </div>
    )
}

export default App
```

### 10.8.6 useTransition的用法

	一个动画组，根据items的增加删除移动，会开启对应的动画

```jsx
//案例---切换一组数据
import React,{useState} from 'react'
import { useTransition, animated } from 'react-spring';

function App(props) {
    const [items, setItems] = useState([{text:'zhangsan',key:1},{text:'lisi',key:2},{text:'wangwu',key:3}])
    const transitions = useTransition(items, item => item.key, {
        from: { transform: 'translate3d(0,-40px,0)' },
        enter: { transform: 'translate3d(0,0px,0)' },
        leave: { transform: 'translate3d(0,-40px,0)' },
    })

    console.log(transitions)
    return (<div>
        <button onClick={()=>{setItems(state=>[{text:'zhaoliu',key:12},...state])}}>增加</button>
        {
            transitions.map(({ item, props, key }) =>
            <animated.div key={key} style={props}>{item.text}</animated.div>
        )
        }
    </div>) 
}

export default App
```

```jsx
//案例---切换组件

import React, { useState } from 'react'
import { useTransition, animated } from 'react-spring';

function App(props) {
    const [toggle, setToggle] = useState(false)
    const transitions = useTransition(toggle, null, {
        from: { position: 'absolute', opacity: 0 },
        enter: { opacity: 1 },
        leave: { opacity: 0 },
    })
    console.log(transitions)
    return (<div>
        <button onClick={() => { setToggle(state => !state) }}>切换</button>
        {
            transitions.map(({ item, key, props }) =>
                <React.Fragment key={key}>
                    {item && <animated.div key={key} style={props}>切换单个组件</animated.div>}
                    {/* {item ? <animated.div style={props}>组件1</animated.div> : <animated.div style={props}>组件2</animated.div>} */}
                </React.Fragment>
            )
        }
    </div>)
}

export default App
```

```jsx
//案例：切换路由
const location = useLocation()
const transitions = useTransition(location, location => location.pathname, { ... })
return transitions.map(({ item, props, key }) => (
  <animated.div key={key} style={props}>
    <Switch location={item}>
      <Route path="/a" component={A} />
      <Route path="/b" component={B} />
      <Route path="/c" component={C} />
    </Switch>
  </animated.div>
))
```

```jsx
//背景轮播图案例

#1.App.jsx
import React, { useState,useEffect } from 'react'
import { useTransition, animated } from 'react-spring';
import './app.css'

function App(props) {
    const slides = [
        { id: 0, url: 'photo-1544511916-0148ccdeb877?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1901&q=80i' },
        { id: 1, url: 'photo-1544572571-ab94fd872ce4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&w=1534&q=80' },
        { id: 2, url: 'reserve/bnW1TuTV2YGcoh1HyWNQ_IMG_0207.JPG?ixlib=rb-1.2.1&w=1534&q=80' },
        { id: 3, url: 'photo-1540206395-68808572332f?ixlib=rb-1.2.1&w=1181&q=80' },
    ]

    const [index, setIndex] = useState(0)
    const transitions = useTransition(slides[index], item => item.id, {
        from: { opacity: 0 },
        enter: { opacity: 1 },
        leave: { opacity: 0 }
    })

    //在hooks中，使用useEffect，可以直接在函数组件内处理生命周期事件。 
    //如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合
    useEffect(() => void setInterval(() => setIndex(state => (state + 1) % 4), 2000), [])


    return (<div>
        {
            transitions.map(({ item, props, key }) => (
                <animated.div
                    key={key}
                    className="bg"
                    style={{ ...props, backgroundImage: `url(https://images.unsplash.com/${item.url}&auto=format&fit=crop)` }}
                />
            ))
        }
    </div>)
}

export default App

#2.app.css

.App {
    font-family: sans-serif;
    text-align: center;
  }
  
  .bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-size: cover;
    background-position: center;
    will-change: opacity;
  }
  
```



### 10.8.7 useChain的用法

useChain可以让一系列动画沿着一定的序列运行

```jsx
// The spring will start right away: 0.0 * 1000ms = 0ms
// The transition will start after: 0.5 * 1000ms (the timeFrame default) = 500ms
useChain([springRef, transitionRef], [0, 0.5] /*1000*/
```

```jsx
//案例：点击div展开子控件
#1.App.jsx
import React, { useState, useRef } from 'react'
import { render } from 'react-dom'
import { useTransition, useSpring, useChain, animated } from 'react-spring'
import './app.css'


function App(props) {
    const data = [{ name: 1, css: "red" }, { name: 2, css: "blue" }, { name: 3, css: "yellow" }, { name: 4, css: "pink" }];
    //定义一个open state用于控制窗口是否被打开
    const [open, setOpen] = useState(false)
    //创建一个springRef的引用
    const springRef = useRef()
    //创建Spring动画,作用是当open为true的时候，让父盒子变大
    const { size, background, ...rest } = useSpring({
        ref: springRef,
        from: { size: '30%', background: 'hotpink' },
        to: { size: open ? '100%' : '30%', background: open ? 'white' : 'hotpink' }
    })


    //创建一个transRef的引用
    const transRef = useRef()
    //创建过渡动画(当父盒子打开后，若干子盒子呈现)
    const transitions = useTransition(open ? data : [], item => item.name, {
        ref: transRef,
        unique: true, //动画进入和离开使用相同的key
        trail: 400/data.length,  //动画的延迟时间
        from: { opacity: 0, transform: 'scale(0)' },
        enter: { opacity: 1, transform: 'scale(1)' },
        leave: { opacity: 0, transform: 'scale(0)' }
    })

    // 创建动画链  当open是true，先执行springRef动画；否则先执行transRef动画
    // 当open为true，0~0.1执行springRef动画，0.1之后执行transRef动画
    // 当open为false，0~0.6执行transRef动画，0.6之后执行springRef动画
    useChain(open ? [springRef, transRef] : [transRef, springRef], [0, open ? 0.1 : 0.6])

    return (
        <animated.div className="parent" style={{ width: size, height: size, background }} onClick={() => setOpen(open => !open)}>
            {transitions.map(({ item, key, props }) => (
                <animated.div className="item" key={key} style={{ ...props, background: item.css }} />
            ))}
        </animated.div>
    )
}

export default App



#2.app.css
html,body,#app{
    width: 100%;
    height: 100%;;
}

body{
    background: cornflowerblue;
    padding: 50px;
    box-sizing: border-box;
}

.parent{
    margin: 0 auto;
}

.item{
   width: 100px;
   height: 100px;
   display: inline-block; 
   margin-left: 20px;
   margin-top: 20px;
}
```

11.AntDesgin
===================== 

## 11.1 AntDesgin使用

http://design.alipay.com/develop/web/react/introduce

```
$ npm install antd

import 'antd/dist/antd.css'; 
import { DatePicker } from 'antd';
ReactDOM.render(<DatePicker />, mountNode);
```

使用如下方法实现按需加载：

- 配合插件 [babel-plugin-import](https://github.com/ant-design/babel-plugin-import) 使用 `import { DatePicker } from 'antd';`

  ```
  npm i babel-plugin-import -D
  ```

  ```javascript
  //修改.babelrc文件
  "plugins": ["transform-runtime", ["import", { "libraryName": "antd", "style": "css" }]]

  //当.babelrc中添加了babel-plugin-import插件之后，会自动帮我们导入对应组件的样式，所以此时我们无需再写import 'antd/dist/antd.css'; 这个代码了
  ```

- 没有使用按需加载和使用按需加载之后

![1553156690886](assets\1553156690886.png)

![1553157308746](assets\1553157308746.png)

## 11.2 react-virtualized

<https://segmentfault.com/a/1190000017233625>

	react-virtualized是一个实现虚拟列表较为优秀的组件库，react-virtualized提供了一些基础组件用于实现虚拟列表，虚拟网格，虚拟表格等等，它们都可以减小不必要的dom渲染。此外还提供了几个高阶组件，可以实现动态子元素高度，以及自动填充可视区等等。
	
	react-virtualized的基础组件包含：

> Grid：用于优化构建任意网状的结构，传入一个二维的数组，渲染出类似棋盘的结构。
> List：List是基于Grid来实现的，但是是一个维的列表，而不是网状。
> Table：Table也是基于Grid来实现，表格具有固定的头部，并且可以在垂直方向上滚动
> Masonry：同样可以在水平方向，也可以在垂直方向滚动，不同于Grid的是可以自定义每个元素的大小，或者子元素的大小也可以是动态变化的
> Collection：类似于瀑布流的形式，同样可以水平和垂直方向滚动。

	值得注意的是这些基础组件都是继承于React中的PureComponent，因此当state变化的时候，只会做一个浅比较来确定重新渲染与否。

### 11.2.1 Grid的使用

```javascript
import React, { useState, useRef } from 'react'
import { Grid } from 'react-virtualized';


function App(props) {
    const list = [
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU'],
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU'],
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU'],
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU'],
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU'],
        ['Jony yu', 'Software Engineer', 'Shenzhen', 'CHINA', 'GUANGZHOU']
    ];
    function cellRenderer({ columnIndex, key, rowIndex, style }) {
        return (
            <div
                key={key}
                style={style}
            >
                {list[rowIndex][columnIndex]}
            </div>
        )
    }
    return(
        <Grid
            cellRenderer={cellRenderer}
            columnCount={list[0].length} //每行多少列
            columnWidth={100}       //每列宽度       
            height={300}         //Grid总高度
            rowCount={list.length}    //总行数
            rowHeight={80}        //每行高度
            width={300}          //Grid总宽度
        />
    );
}

export default App
```

### 11.2.2 List的使用

```jsx
import React, { useState, useRef } from 'react'
//CellMeasurer 高阶组件，用来计算每个Cell的高度
//CellMeasurerCache 计算Cell行高，填充父亲高度
import { List, AutoSizer, CellMeasurer, CellMeasurerCache } from 'react-virtualized';

//创建一个默认的Cache用来指定cell默认行高
const cache = new CellMeasurerCache({ defaultHeight: 30, fixedWidth: true })

function App(props) {

    const rowCount = 1000;
    const list = Array(rowCount).fill().map(() => {
        return {
            units: '子元素太长，换行后改变了子元素的高度后无法子适应，也就是说仅仅通过基础的组件List是不支持子元素的高度动态改变的场景子元素太长，换行后改变了换行后改变了换行后改变了换行后改变了换行后改变了换行后改变了换行后改变了aaaaaaa',
        }
    })

    function rowRenderer({
        key,  
        index, //索引，第几条数据
        style, //样式
        parent //父亲
    }) {
        return (
            <CellMeasurer
                cache={cache}
                key={key}
                parent={parent}
                rowIndex={index}
                style={style}
            >
                <div
                    style={style}
                >
                    {list[index].units}
                </div>
            </CellMeasurer>
        )
    }

    return (<div style={{height:'100%'}}>
        {/*AutoSizer 让List的宽度由父亲宽度撑开*/}
        <AutoSizer>
            {({ height, width }) => (
                <List
                    width={width}   //List总宽度
                    height={height}  //List总高度
                    rowCount={list.length}  //总行数
                    rowHeight={cache.rowHeight}   //行高
                    rowRenderer={rowRenderer}  //渲染每一行使用的函数
                    deferredMeasurementCache={cache} //默认cell的cache
                />
            )}
        </AutoSizer>
    </div>
    )
}

export default App
```

### 12.2.3 无限滚动

<https://bvaughn.github.io/react-virtualized/#/components/InfiniteLoader>

参照资料中的  test-react-virtualized-master.zip

# 12.Flux和Redux

## 12.1 常用软件架构思想

### a) MVC

**Model**

> Model负责保存应用数组，和后端交互同步应用数据，或校验数据。Model主要与业务数据相关，与应用内交互状态无关

**View**

> View是Model的可视化，表示当前状态的视图。前端View负责构建和维护DOM元素。更新Model的实际任务是在Controller上。用户可以与View交互，包括读取和编辑Model，在Model中获取或设置属性值。*一个view通常对应一个model，所以在世实际开发过程中，会面临多个view对应多个model的状况*

**Controller**

> Controller负责连接view和model，model的任何变化会应用到view中，view的操作会痛殴controller应用到model中。

MVC有两个很明显的问题：

	1.m层和v层直接打交道，导致这两层耦合度高
	2.因为所有逻辑都写在c层，导致c层特别臃肿

![1553222527572](assets\1553222527572.png)

### b) MVVM

近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。

![1553222636183](assets\1553222636183.png)

在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的，在它们之间存在着 ViewModel 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model(数据) 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。这个一来一回的过程就是我们所熟知的双向绑定。

### c) Flux

Flux 是一种架构思想，专门解决软件的结构问题。它跟[MVC 架构](http://www.ruanyifeng.com/blog/2007/11/mvc.html)是同一类东西，但是更加[简单和清晰](http://www.infoq.com/news/2014/05/facebook-mvc-flux)。

首先，Flux将一个应用分成四个部分。

> - **View**： 视图层
> - **Action**（动作）：视图层发出的消息（比如mouseClick）。然后在mouseClick中将出现数据从应用程序发送到store的有效信息负载。可以将其理解为用户的某个操作而做出的反应，是改变store数据的唯一方法
> - **Dispatcher**（派发器）：用来接收Actions、执行回调函数
> - **Store**（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

**Flux 的最大特点，就是数据的"单向流动"。**

> 1. 用户访问 View
> 2. View 发出用户的 Action
> 3. Dispatcher 收到 Action，要求 Store 进行相应的更新
> 4. Store 更新后，发出一个"change"事件
> 5. View 收到"change"事件后，更新页面

![1553222968163](assets\1553222968163.png)

![1553223019430](assets\1553223019430.png)

## 12.2 Redux

http://cn.redux.js.org/

### a) Redux介绍

    我们把Flux看做一个框架的理念的话，Redux是Flux的一种实现。Redux是SPA单页面应用程序中多个组件之间共享数据的一种方式。
    
    Flux的基本原则是“单向数据流”，Redux在此基础上强调三个基本原则：
    1.唯一数据源 ：唯一数据源指的是应用的状态数据应该只存储在唯一的一个Store上。
    2.保持状态只读 ： 保持状态只读，就是说不能去直接修改状态，要修改Store的状态，必须要通过派发一个action对象完成。
    3.数据改变只能通过纯函数完成 ：这里所说的纯函数就是把Reducer，Reducer描述了state状态如何修改。Redux这个名字的前三个字母Red代表的就是Reducer，其实Redux名字的含义就是Reducer+Flux。

![1553225378607](assets\1553225378607.png)

### b) Redux的基本使用

    React和Redux事实上是两个独立的产品，一个应用可以使用React而不使用Redux，也可以使用Redux而不使用React，但是如果两者结合使用，没有理由不使用一个名为react-dedux的库，这个库能大大简化代码的书写。

```
npm install redux --save
```

```javascript
#1.main.js
import React from 'react'                        // 创建组件、虚拟DOM元素，生命周期
import ReactDOM from 'react-dom'      // 把创建好的 组件 和 虚拟DOM 放到页面上展示的
import { createStore } from 'redux'

import App from "./app.jsx"

/**
 * 1.创建reducer
    这是一个 reducer，形式为 (state, action) => state 的纯函数.。描述了 action 如何把 state 转变成下一个 state。
    state 的形式取决于你，可以是基本类型、数组、对象、甚至是 Immutable.js 生成的数据结构。惟一的要点是当 state 变化时需要返回全新的对象，而不是修改传入的参数。
 */
function counter(state = 0, action) {
    switch (action.type) {
        case 'ADD':
            return state + 1
        case 'MINUS':
            return state - 1
        default:
            return state
    }
}

//2.声明 actions
//action 是改变 state 的唯一途径，是一个普通的 javascript 对象，它描述了一个行为且是改变 state 的唯一途径。从用户UI操作事件、网络请求回调和 WebSocket 等其他地方获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 指明具体的行为名称，且能附带上额外的信息。
function addFn() {
    return { type:'ADD' }
}
function minusFn() {
    return { type:'MINUS' }
}

// 3.创建 Redux store 来存放应用的状态。store对象的API 有 { subscribe, dispatch, getState }。
let store = createStore(counter)


// 4.订阅更新，监听state的变化
store.subscribe(() => console.log(store.getState()))

// 5.触发action
store.dispatch(addFn())  // 1
store.dispatch(addFn())  // 2
store.dispatch(minusFn())  // 1


// 6.渲染页面
function render() {
    ReactDOM.render(<App store={store} addFn={addFn} minusFn={minusFn}/>, document.getElementById('app'));
}
render()
// 每当state状态发生变化的时候，重新渲染页面
store.subscribe(render)
    
    
#2.app.jsx
import React, { Component } from 'react';

class App extends Component {
    constructor(props){
        super(props)
    }
    render() {
        const store=this.props.store
        const addFn=this.props.addFn
        const minusFn=this.props.minusFn
        const init=store.getState()
        return (
            <div className="App">
                <h1>你好吗？</h1>
                {<p>现在的总数是：{store.getState()}</p>}
                {<button onClick={ ()=>store.dispatch( addFn() ) }>加1</button>}
                {<button onClick={ ()=>store.dispatch( minusFn() ) }>减1</button>}
            </div>
        );
    }
}
export default App;
```

### c) redux异步处理

     redux默认情况下只处理同步，想要处理异步，需要上面安装的redux-thunk插件

```javascript
npm install redux-thunk -S

#1.修改main.js 代码 
import { createStore ,applyMiddleware } from 'redux';
import thunk from 'redux-thunk'
//使用applyMiddleware在创建store的时候开启中间件
const store=createStore(couter ,applyMiddleware(thunk))

function addFn() {
    return { type:'ADD' }
}
function minusFn() {
    return { type:'MINUS' }
}
function addAsynFn() {
    return dispatch=>{
        setTimeout(()=>{
            dispatch(addFn())
        },2000)
    }
}

function render() {
    ReactDOM.render(<App store={store} addFn={addFn} minusFn={minusFn} addAsyncFn={addAsynFn}/>, document.getElementById('app'));
}
                    
#2.修改app.jsx代码
render() {
        const store=this.props.store
        const addFn=this.props.addFn
        const minusFn=this.props.minusFn
        const addAsynFn=this.props.addAsyncFn
        console.log(addAsynFn)
        const init=store.getState()
        return (
            <div className="App">
                <h1>你好吗？</h1>
                {<p>现在的总数是：{store.getState()}</p>}
                {<button onClick={ ()=>store.dispatch( addFn() ) }>加1</button>}
                {<button onClick={ ()=>store.dispatch( minusFn() ) }>减1</button>}
                {<button onClick={ ()=>store.dispatch( addAsynFn() ) }>异步加1</button>}
            </div>
        );
    } 
```

### d) 抽离main.js中的reducer和actions到单独模块

```javascript
#1.reducers/index.js
//1.创建reducer,描述了如何根据action将state修改为下一个state
export function counter(state = 0, action) {
    switch (action.type) {
        case 'ADD':
            return state + 1
        case 'MINUS':
            return state - 1
        default:
            return state
    }
}

#2.actions/action.js
//2.声明 actions
export function addFn() {
    return { type:'ADD' }
}
export function minusFn() {
    return { type:'MINUS' }
}
export function addAsynFn() {
    return dispatch=>{
        setTimeout(()=>{
            dispatch(addFn())
        },2000)
    }
}

#3.main.js
import React from 'react'                        // 创建组件、虚拟DOM元素，生命周期
import ReactDOM from 'react-dom'      // 把创建好的 组件 和 虚拟DOM 放到页面上展示的
import { createStore,applyMiddleware  } from 'redux'
import thunk from 'redux-thunk'
import { counter } from './reducers/index'
import {addFn,minusFn,addAsynFn} from './actions/action'

import App from "./app.jsx"

// 3.创建 Redux store 来存放应用的状态。store对象的API 有 { subscribe, dispatch, getState }。
let store = createStore(counter,applyMiddleware(thunk))


// 4.订阅更新，监听state的变化
store.subscribe(() => console.log(store.getState()))

// 5.触发action
store.dispatch(addFn())  // 1
store.dispatch(addFn())  // 2
store.dispatch(minusFn())  // 1


// 6.渲染页面
function render() {
    ReactDOM.render(<App store={store} addFn={addFn} minusFn={minusFn} addAsyncFn={addAsynFn}/>, document.getElementById('app'));
}
render()
// 每当state状态发生变化的时候，重新渲染页面
store.subscribe(render)
    
#4. app.jsx 没有变化
```

### e) react和redux的结合使用

1.插件：react-redux

2.不适用subscribe发布事件

3.提供provider和connect两个接口

	provider作用：如果我们手动将state对象一层一层的传入容器组件应用小还好说，大应用深层的组件简直累死了，绝对让你传到怀疑人生。react-redux提供了Provider组件让我们省了不少功夫，用法就是在我们根组件外部嵌套一层Provider，传入store （使用全局的store有风险）这样所以的子组件都可以开心地拿到state了 。
	
	Provider接受store作为其props，并声明为context的属性之一 。子组件在声明了contextTypes之后可以通过this.context.store访问到store。
	
	connect用于连接 React 组件与 Redux store。连接操作不会改变原来的组件类。反而返回一个新的已与 Redux store 连接的组件类。
	
	不过现在我们仅仅是通过展示组件生成了一个容器组件并且将它们连接了起来，但是容器组件中并没有数据和逻辑，只是一具空壳毫无意义，所以我们还需要向这个connect函数中传入两个参数。mapStateToProps负责将state的数据映射到展示组件的this.props。mapDispatchToProps负责定义发送action的函数映射到展示组件的this.props。

```
npm install react-redux --save
```

```javascript
#1.main.js

import React from 'react'                        // 创建组件、虚拟DOM元素，生命周期
import ReactDOM from 'react-dom'      // 把创建好的 组件 和 虚拟DOM 放到页面上展示的
import { createStore,applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import { counter } from './reducers/index'
import { Provider } from 'react-redux'

import App from "./app.jsx"

// 3.创建 Redux store 来存放应用的状态。store对象的API 有 { subscribe, dispatch, getState }。
let store = createStore(counter,applyMiddleware(thunk))

// 4.订阅更新，监听state的变化
store.subscribe(() => console.log(store.getState()))


ReactDOM.render(
    <Provider store={store}>
        < App />
    </Provider>
    , document.getElementById('app'));

#2.app.jsx
import React, { Component } from 'react';
import { connect } from 'react-redux'
import {addFn,minusFn,addAsynFn} from './actions/action'

class App extends Component {
    constructor(props){
        super(props)
    }
    render() {
        const num=this.props.num
        const addFn=this.props.addFn
        const minusFn=this.props.minusFn
        const addAsynFn=this.props.addAsynFn
        console.log(addAsynFn)
        return (
            <div className="App">
                <h1>你好吗？</h1>
                {<p>现在的总数是：{num}</p>}
                {<button onClick={ addFn }>加1</button>}
                {<button onClick={ minusFn }>减1</button>}
                {<button onClick={ addAsynFn }>异步加1</button>}
            </div>
        );
    }
}


//将state状态映射到属性里面,之后可以通过props获取
const mapStatetoProps=(state)=>{
    return {num:state}
}

//addFn 自动有了dispatch的功能 onClick={addFn} ; addFn  minusFn  minusFn会被映射到props里面
const mapDispatchToProps={addFn,minusFn,addAsynFn}


//为App组件提供数据和逻辑。mapStateToProps负责将state的数据映射到展示组件的this.props。mapDispatchToProps负责定义发送action的函数映射到展示组件的this.props
App=connect(mapStatetoProps,mapDispatchToProps)(App)
export default App;

#3.其他 reducers/index.js 和 actions/action.js 无变化
```

### f) 多个reducer之间的合并问题

```javascript
#1. reducers/counter.js

export default function counter(state = 0, action) {
    switch (action.type) {
        case 'ADD':
            return state + 1
        case 'MINUS':
            return state - 1
        default:
            return state
    }
}


#2. reducers/city.js
export default function location(state = '无锡', action) {
    switch (action.type) {
        case 'CHOOSECITY':
            return action.city
        default:
            return state
    }
}


#3. reducers/index.js

import {combineReducers} from 'redux'

//redux提供的用于多个reducer合并的方法
// 里面是个对象。罗列需要合并的reducer
import counter from './counter';  //项目中需要的reducer
import city from './city';   //项目中需要的reducer

console.log(combineReducers)

export default combineReducers({counter,city})


#4.actions/action.js
export function addFn() {
    return { type:'ADD' }
}
export function minusFn() {
    return { type:'MINUS' }
}

/*该action接收参数，在dispatch当前action的时候可以传递参数*/
export function changeCityFn(name) {
    return { type:'CHOOSECITY',city:name }
}

export function addAsynFn() {
    return dispatch=>{
        setTimeout(()=>{
            dispatch(addFn())
        },2000)
    }
}

#5. main.js
import React from 'react'                        // 创建组件、虚拟DOM元素，生命周期
import ReactDOM from 'react-dom'      // 把创建好的 组件 和 虚拟DOM 放到页面上展示的
import { createStore,applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import reducer from './reducers/index'
import { Provider } from 'react-redux'


import App from "./app.jsx"

let store = createStore(reducer,applyMiddleware(thunk))

store.subscribe(() => console.log(store.getState()))

ReactDOM.render(
    (<Provider store={store}>
        < App />
    </Provider>)
    , document.getElementById('app'));


#4. app.jsx 
import React from 'react'

import { connect } from 'react-redux'
import {addFn,minusFn,addAsynFn,changeCityFn} from '../actions/action'


class App extends React.Component {
    constructor(props, context) {
        super(props,context)
    }

    render() {
        const num=this.props.num
        const city = this.props.city
        const addFn=this.props.addFn
        const minusFn=this.props.minusFn
        const addAsynFn=this.props.addAsynFn
        const changeCityFn=this.props.changeCityFn
        return <div>
            <h1>你好吗？</h1>
            <h1>{city}</h1>
            {<p>现在的总数是：{num}</p>}
            {<button onClick={ addFn }>加1</button>}
            {<button onClick={ minusFn }>减1</button>}
            {<button onClick={ addAsynFn }>异步加1</button>}
            {/* 这里通过箭头函数dispatch对应的方法，并传递参数 */}
            {<button onClick={ ()=>{
                changeCityFn("苏州")
            } }>改变城市</button>}
            这是home
        </div>
    }
}

//将state状态映射到属性里面,之后可以通过props获取
const mapStatetoProps=(state)=>{
    return {num:state.counter,city:state.city}
}

//addFn 自动有了dispatch的功能 onClick={addFn} ; addFn  minusFn  minusFn会被映射到props里面
const mapDispatchToProps={addFn,minusFn,addAsynFn,changeCityFn}


//为App组件提供数据和逻辑。mapStateToProps负责将state的数据映射到展示组件的this.props。mapDispatchToProps负责定义发送action的函数映射到展示组件的this.props
App=connect(mapStatetoProps,mapDispatchToProps)(App)

export default App
```

## 12.3 react不可变数据

**1.在ReactJS中的数据对象**

	在ReactJS 中主要是props 和state：

```
//1.props是不可变的
props在子组件构造时由父组件传人子组件或自定义初始值，在子组件中不能改变props的值，只能读取：采用this.props.name。

//2.state是可变的
state是在组件内部运用的。在组件内部均可改变。改变的方式是this.setState()。
```

**2.如何在Reactjs中减少render**

	那么如何在reactjs中减少render提高性能呢，主要还是从props和state入手。在Reactjs中只要state变化或者props变化,都会重新render，这里的变化并非值真变了，即使是相同的值，因为重新输入了，也会导致render。因此reactjs提供了shouldComponentUpdate和PureComponent来阻止。

```javascript
//方式一：使用shouldComponentUpdate方法
function shouldComponentUpdate (nextProps, nextState) {
    //我们需要在state和props有新值的时候进行判断，是否需要render，如果不需要，则返回false。
    return nextProps.id !== this.props.id;
}

//方式二：使用PureComponent类 
class ListOfWords extends React.PureComponent {
 render() {
     return <div>{this.props.words.join(',')}</div>;
 }
}

class WordAdder extends React.Component {
 constructor(props) {
     super(props);
     this.state = {
         words: ['marklar']
     };
     this.handleClick = this.handleClick.bind(this);
 }
 handleClick() {
     // This section is bad style and causes a bug
     const words = this.state.words;
     words.push('marklar');
     this.setState({words: words});
  
 }
 render() {
     return (
         <div>
             <button onClick={this.handleClick}>click</button>
             <ListOfWords words={this.state.words} />
         </div>
     );
 }
}
/*
1.继承PureComponent时，不能再重写shouldComponentUpdate
2.继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致
3.上面代码中，无论你怎么点击按钮，ListOfWords渲染的结果始终没变化，原因就是WordAdder的word的引用地址始终是同一个。
4.我们可以这样修改state，此时页面会发生变化，因为给words赋值了一个新对象
   this.setState({words:[...words]});
*/
```

**3.如何简单快捷的判断是否需要render**

	从上面我们可以看出reactjs提供了阻止render的方法，但是如何快速判断是否需要render依然是个问题，因为判断一个复杂的数据对象是否跟之前的值是否相同并不容易。
	
	Redux将这个问题极简化了，整个应用共用一个state。但也带来了更复杂的问题，就是state的结构可能非常复杂，如果判断是否更新呢？Redux又一次极简了，那就是采用不可变数据。
	
	我们在判断数据是否相同时，并不需要深入判断数据对象的值是否相同，只需要浅比较即可，也就是判断是否为同一个数据对象地址，因为不可变数据对象在数据变化时均会重新创建一个新的数据对象，数据对象的地址不会相同。这也就是为什么在Reactjs，Redux中才有不可变数据对象。

# 13.Fetch

## 13.1 Fetch介绍

	在jQuery开发时代，jQuery已经为我们封装了非常优雅的ajax函数，并且针对各个浏览器都做好了兼容，非常方便。但是当我们使用React Vue或者angular去开发webpap的时候，我们还会再为了一个ajax去使用jQuery吗？这是一个问题。
	
	另外一个问题，JavaScript中的ajax很早之前就有一个诟病，就是复杂业务下的callback嵌套问题。Promise正式js中解决这一问题的钥匙，并且作为标准在ES6中发布，接下来要介绍的fetch就用到了最新的Promise。
	
	Fetch就是一种可替代ajax获取/提交数据的技术，有些高级浏览器已经可以使用window.fecth使用了。相比于使用jQuery.ajax更轻量，而且它支持Promise，更加符合现在的编程习惯。

## 13.2 Fetch基本使用

```javascript
npm install whatwg-fetch --save

//  fetch在各个浏览器低版本的情况下是不被支持的，由于fetch是基于promise实现的，所以在低版本浏览器中promise未必被原生支持
npm install es6-promise --save  

// 开启react项目中的服务器代码进行测试
```

### a) GET请求

```javascript
#1. main.js 
import 'whatwg-fetch'
import 'es6-promise'

fetch('/api/homead',{
        credentials:"include",
        /*
   		 fetch不管在同域还是在跨域的情况下，默认都不携带cookie的，所以那些需要权限验证的请求就无法正常获取到数据，这时候需要配置credentials项，有一下三个选项可添：
     	 omit： 默认值，忽略cookie的发送
   		 same-origin： 表示cookie只能同域发送，不能跨域发送
   		 include： 表示既可以同域发送，也可以跨域发送
		*/
    })
    .then(response => {
        //有三种方式解析获取到的数据：
        //1  json数据       用reponse.json()来解析
        //2 xml格式文件  用response.text()来解析
        //3 图片文件       用response.blob()来解析
        return  response.json();
    })
    .then((data)=>{
        console.log(data);
    })
    
#2.webpack.config.js 中配置代理开启跨域请求
    devServer: {
        proxy: {
            '/api/*': {
                target: 'http://127.0.0.1:3001/',
                changeOrigin: true,
                secure: false
            }
        }
    },
    //表示凡是以api开头的请求都会自动去请求http://127.0.0.1:3001/ 地址下的服务
```

### b) POST请求

```javascript
    //post请求需要提交的数据
    fetch('/api/submitComment', {
        method: 'post',   //请求方式
        credentials:"include",
        headers: {
            //post请求格式
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        //post请求发送的数据需要是这样的
        body: "name=zhangsan&content=宝宝不开心"
    })
    .then(response => response.json())
    .then(data=>{
        console.log(data);
    }).catch(error => console.log('error is', error));
```

### c) fetch请求的封装

```javascript
import 'whatwg-fetch'
import 'es6-promise'

//导出get请求
export function fetchget(url) {
    var result = fetch(url, {
        credentials: 'include',
        headers: {
            'Accept': 'application/json, text/plain, */*'
        }
    });
    return result;
}


// 发送 post 请求
export function fetchpost(url, paramsObj) {
    var result = fetch(url, {
        method: 'POST',
        credentials: 'include',
        headers: {
            'Accept': 'application/json, text/plain, */*',
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: obj2params(paramsObj)
    });
    return result;
}

// 将对象拼接成 key1=val1&key2=val2&key3=val3 的字符串形式
function obj2params(obj) {
    var result = '';
    var item;
    for (item in obj) {
        result += '&' + item + '=' + encodeURIComponent(obj[item]);
    }

    if (result) {
        result = result.slice(1);
    }

    return result;
}
```

# 14. 相关文章

+ [2018 年，React 将独占前端框架鳌头？](https://mp.weixin.qq.com/s/gV-w_rRfdBVAqsOpBGZaVw)
+ [前端框架三巨头年度走势对比：Vue 增长率最高](https://mp.weixin.qq.com/s/0wXWqKIigaKzMSfy4vJMVw)


+ [React数据流和组件间的沟通总结](http://www.cnblogs.com/tim100/p/6050514.html)
+ [单向数据流和双向绑定各有什么优缺点？](https://segmentfault.com/q/1010000005876655/a-1020000005876751)
+ [怎么更好的理解虚拟DOM?](https://www.zhihu.com/question/29504639?sort=created)
+ [React中文文档 - 版本较低](http://www.css88.com/react/index.html)
+ [React 源码剖析系列 － 不可思议的 react diff](http://blog.csdn.net/yczz/article/details/49886061)
+ [深入浅出React（四）：虚拟DOM Diff算法解析](http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&isappinstalled=0)
+ [一看就懂的ReactJs入门教程（精华版）](http://www.cocoachina.com/webapp/20150721/12692.html)
+ [CSS Modules 用法教程](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)
+ [将MarkDown转换为HTML页面](http://blog.csdn.net/itzhongzi/article/details/66045880)
+ [win7命令行 端口占用 查询进程号 杀进程](https://jingyan.baidu.com/article/0320e2c1c9cf0e1b87507b26.html)
+ [类型校验](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)

- [Animation Add-Ons](https://reactjs.org/docs/animation.html#high-level-api-reactcsstransitiongroup)

## 安装 React Developer Tools 调试工具

[React Developer Tools - Chrome 扩展下载安装地址](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN)
